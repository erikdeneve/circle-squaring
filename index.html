<html>
<title>Circle-Squaring</title>
<head>
<meta charset="UTF-8">
<style>
* { margin:0; padding:0; } /* to remove the top and left whitespace */
html, body { width:100%; height:100%; } /* just to be sure these are full screen*/
canvas { display:block; } /* To remove the scrollbars */
</style>
</head>
<body>
<canvas id="myCanvas"></canvas> 
<script>
// ======================================
// utility functions
function crossProduct2D( v, w ) {
    return v.x*w.y - v.y*w.x;
}
// --------------------------------------
function sub( a, b ) {
    return new Point2D( a.x - b.x, a.y - b.y );
}
// --------------------------------------
function lineSegmentsIntersect( p, p2, q, q2 ) {
    // two line segments: [p,p2] and [q,q2] - do they intersect?
    // http://stackoverflow.com/a/565282/126823
    var r = sub(p2, p);
    var s = sub(q2, q);

    var uNumerator = crossProduct2D(sub(q, p), r);
    var denominator = crossProduct2D(r, s);

    if( uNumerator == 0 && denominator == 0 ) {
        // colinear, so do they overlap?
        return ((q.x - p.x < 0) != (q.x - p2.x < 0) != (q2.x - p.x < 0) != (q2.x - p2.x < 0)) ||
                ((q.y - p.y < 0) != (q.y - p2.y < 0) != (q2.y - p.y < 0) != (q2.y - p2.y < 0));
    }

    if( denominator == 0 ) {
        // lines are parallel
        return false;
    }

    var u = uNumerator / denominator;
    var t = crossProduct2D(sub(q, p), s) / denominator;

    return (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);
}
// ======================================
// Point2D class
function Point2D( x, y ) {
    this.x = x;
    this.y = y;
};
// --------------------------------------
Point2D.prototype.getAsString = function() {
    return this.x + "," + this.y;
}
// ======================================
// Polygon class
function Polygon() {
    this.points = new Array(); // a list of Point2D's
};
// --------------------------------------
Polygon.prototype.drawPath = function( ctx ) {
    ctx.beginPath();
    ctx.moveTo( this.points[0].x, this.points[0].y );
    for( var i = 1; i < this.points.length; ++i )
        ctx.lineTo( this.points[i].x, this.points[i].y );
    ctx.closePath();
};
// --------------------------------------
Polygon.prototype.getArea = function() {
    //  Public-domain function by Darel Rex Finley, 2006.
    var area=0.0;
    var i, j = this.points.length-1;
    for( i = 0; i < this.points.length; ++i )
    {
        area += ( this.points[j].x + this.points[i].x ) * ( this.points[j].y - this.points[i].y ); 
        j = i;
    }
    return area * 0.5; 
}
// --------------------------------------
function getCircle( center, radius, n )
{
    var poly = new Polygon();
    for( var i = 0; i < n; ++i )
    {
        poly.points[i] = new Point2D( center.x + radius * Math.cos( i * 2.0 * Math.PI / n ), 
                                      center.y + radius * Math.sin( i * 2.0 * Math.PI / n ) );
    }
    return poly;
};
Polygon.prototype.contains = function( p ) {
    // move p to polygon coordinates
    var c = false;
    var i, j;
    var vertxi,vertyi,vertxj,vertyj;
    for( i = 0, j = this.points.length-1; i < this.points.length; j = i++ ) 
    {
        vertxi = this.points[i].x;
        vertyi = this.points[i].y;
        vertxj = this.points[j].x;
        vertyj = this.points[j].y;
        if ( ((vertyi>p.y) != (vertyj>p.y)) && (p.x < (vertxj-vertxi) * (p.y-vertyi) / (vertyj-vertyi) + vertxi) )
        {
            c = !c;
        }
    }
    return c;
}
// --------------------------------------
Polygon.prototype.getAsString = function() {
    var spec = this.points.length;
    for( var i = 0; i < this.points.length; ++i )
        spec += "," + this.points[i].getAsString();
    return spec;
}
// --------------------------------------
function polygonRelation( poly1, poly2 ) {
    // return 1 if poly1 is entirely inside poly2
    // return -1 if poly1 is entirely outside poly2
    // return 0 if poly1 and poly2 have intersecting line segments
    for( var i = 0; i < poly1.points.length; ++i )
    {
        var p = poly1.points[ i ];
        var p2 = poly1.points[ (i+1)%poly1.points.length ];
        for( var j = 0; j < poly2.points.length; ++j )
        {
            var q = poly2.points[ j ];
            var q2 = poly2.points[ (j+1)%poly2.points.length ];
            if( lineSegmentsIntersect( p, p2, q, q2 ) )
                return 0;
        }
    }
    return( poly2.contains( poly1.points[0] ) ? 1 : 0 );
}
// ======================================
// Transform class
function Transform( r, p ) {
    this.rotate = r;
    this.translate = p;
};
// --------------------------------------
Transform.prototype.getAsString = function() {
    return this.rotate + "," + this.translate.getAsString();
}
// ======================================
// Piece class
function Piece() {
    this.atOrigin = new Polygon();              // canonical polygon with centroid at the origin
    this.originToTarget = new Array();          // a Transform for each target
    this.hue = Math.random() * 360.0;
};
Piece.prototype.draw = function( ctx ) {
    ctx.fillStyle = "hsla("+this.hue+",50%,50%,0.3)";
    for(var i = 0; i < this.originToTarget.length; ++i ) {
        ctx.save();
        ctx.translate( this.originToTarget[i].translate.x, this.originToTarget[i].translate.y );
        ctx.rotate( this.originToTarget[i].rotate );
        this.atOrigin.drawPath( ctx );
        ctx.fill();
        ctx.restore();
    }
};
Piece.prototype.getAsString = function() {
    var spec = this.atOrigin.getAsString() + "," + this.originToTarget.length + "," + this.hue;
    for( var i = 0; i < this.originToTarget.length; ++i )
        spec += "," + this.originToTarget[i].getAsString();
    return spec;
}
// ======================================
// World class
function World() {
    this.circleCenter = new Point2D( 250, 350 );
    this.circleRadius = 200.0;
    
    this.squareCenter = new Point2D( 650, 350 );
    this.squareRadius = this.circleRadius * Math.sqrt( Math.PI ) / 2.0;

    this.targets = new Array();
    this.targets[0] = getCircle( this.circleCenter, this.circleRadius, 100 );
    this.targets[1] = new Polygon();
    this.targets[1].points[0] = new Point2D( this.squareCenter.x - this.squareRadius, this.squareCenter.y - this.squareRadius );
    this.targets[1].points[1] = new Point2D( this.squareCenter.x - this.squareRadius, this.squareCenter.y + this.squareRadius );
    this.targets[1].points[2] = new Point2D( this.squareCenter.x + this.squareRadius, this.squareCenter.y + this.squareRadius );
    this.targets[1].points[3] = new Point2D( this.squareCenter.x + this.squareRadius, this.squareCenter.y - this.squareRadius );

    this.pieces = new Array();
    
    var test = this.pieces[0] = new Piece();
    test.atOrigin.points[0] = new Point2D( 340, 100 );
    test.atOrigin.points[1] = new Point2D( -100, -100 );
    test.atOrigin.points[2] = new Point2D( 70, 200 );
    test.originToTarget[0] = new Transform( 0.3, this.circleCenter );
    test.originToTarget[1] = new Transform( 0.6, this.squareCenter );
    
    var test2 = this.pieces[1] = new Piece();
    test2.atOrigin.points[0] = new Point2D( -170, 50 );
    test2.atOrigin.points[1] = new Point2D( 70, 200 );
    test2.atOrigin.points[2] = new Point2D( 340, 100 );
    test2.atOrigin.points[3] = new Point2D( -100, -100 );
    test2.originToTarget[0] = new Transform( 0.7, new Point2D( this.circleCenter.x - 50.0, this.circleCenter.y - 50.0 ) );
    test2.originToTarget[1] = new Transform( 2.8, new Point2D( this.squareCenter.x + 50.0, this.squareCenter.y - 50.0 ) );
};
World.prototype.draw = function( canvas, context ) {
    // draw the background
    context.fillStyle = "rgb(200,200,200)";
    context.beginPath();
    context.fillRect( 0, 0, canvas.width, canvas.height );
    context.closePath();
    
    // draw the targets
    context.fillStyle = "rgb(255,255,255)";
    for( var i = 0; i < this.targets.length; ++i )
    {
        this.targets[i].drawPath( context );
        context.fill();
    }
        
    // draw the pieces
    for( var i = 0; i < this.pieces.length; ++i )
    {
        this.pieces[i].draw( context );
    }
    
    // DEBUG: draw the spec string
    context.fillStyle = "rgb(0,0,0)";
    context.font="12px Arial";
    context.fillText( this.getAsString(), 10, 50 );
    context.fillText( this.pieces.length + " : " + this.getAreaCovered()*100 + "%", 10, 80 );
};
World.prototype.isValidSolution = function() {
    // invalid if any piece not fully contained in each target
    // TODO: need to transform pieces/targets first/during
    // invalid if any piece not fully outside any other
    // TODO: need to transform pieces first
}
World.prototype.getAreaCovered = function() {
    // assumes no overlapping
    var area = 0.0;
    for( var i = 0; i < this.pieces.length; ++i )
        area += this.pieces[i].atOrigin.getArea();
    return area / ( Math.PI * this.circleRadius * this.circleRadius );
}
World.prototype.getAsString = function() {
    // targets:
    var spec = this.targets.length + "," + this.circleCenter.getAsString() + "," + this.circleRadius + ","
                + this.squareCenter.getAsString() + "," + this.squareRadius;
                
    // pieces:
    spec += "," + this.pieces.length;
    for( var i = 0; i < this.pieces.length; ++i )
        spec += "," + this.pieces[i].getAsString();
    return spec;
};
// ======================================

(function() 
{
    var canvas = document.getElementById('myCanvas'),
    context = canvas.getContext('2d');
    
    var world = new World();

    // resize the canvas to fill browser window dynamically
    window.addEventListener('resize', resizeCanvas, false);

    function resizeCanvas() 
    {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        /**
        * Your drawings need to be inside this function otherwise they will be reset when 
        * you resize the browser window and the canvas goes will be cleared.
        */
        world.draw( canvas, context ); 
    }
    resizeCanvas();

    window.requestAnimFrame = (function(callback) 
    {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000 / 60);
            };
    })();

    function animate() 
    {
        var canvas = document.getElementById('myCanvas');
        var context = canvas.getContext('2d');

        // draw stuff
        world.draw( canvas, context );

        // request new frame
        requestAnimFrame(function() {
            animate();
        });
    }
    animate();
    
})();
</script> 
</body>
</html>
