<html>
<title>Circle-Squaring</title>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<style>
* { margin:0; padding:0; } /* to remove the top and left whitespace */
html, body { width:100%; height:100%; } /* just to be sure these are full screen*/
canvas { display:block; } /* To remove the scrollbars */
</style>
</head>
<body>
<canvas id="myCanvas"></canvas> 
<script>
// ======================================
// utility functions
function crossProduct2D( v, w ) {
    return v.x*w.y - v.y*w.x;
};
// --------------------------------------
function sub( a, b ) {
    return new Point2D( a.x - b.x, a.y - b.y );
};
// --------------------------------------
function lineSegmentsIntersect( p, p2, q, q2 ) {
    // two line segments: [p,p2] and [q,q2] - do they intersect?
    // http://stackoverflow.com/a/565282/126823
    var r = sub(p2, p);
    var s = sub(q2, q);

    var uNumerator = crossProduct2D(sub(q, p), r);
    var denominator = crossProduct2D(r, s);

    if( uNumerator == 0 && denominator == 0 ) {
        // colinear, so do they overlap?
        return ((q.x - p.x < 0) != (q.x - p2.x < 0) != (q2.x - p.x < 0) != (q2.x - p2.x < 0)) ||
                ((q.y - p.y < 0) != (q.y - p2.y < 0) != (q2.y - p.y < 0) != (q2.y - p2.y < 0));
    }

    if( denominator == 0 ) {
        // lines are parallel
        return false;
    }

    var u = uNumerator / denominator;
    var t = crossProduct2D(sub(q, p), s) / denominator;

    return (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);
};
// ======================================
// Point2D class
function Point2D( x, y ) {
    this.x = x;
    this.y = y;
};
// --------------------------------------
Point2D.prototype.getAsString = function() {
    return this.x + "," + this.y;
}
// ======================================
// Transform class
function Transform( r, p ) {
    this.rotate = r;           // radians
    this.translate = p;        // Point2D
};
// --------------------------------------
Transform.prototype.apply = function( p ) {
    return new Point2D( p.x * Math.cos( this.rotate ) - p.y * Math.sin( this.rotate ) + this.translate.x, 
                        p.x * Math.sin( this.rotate ) + p.y * Math.cos( this.rotate ) + this.translate.y );
};
// --------------------------------------
Transform.prototype.getAsString = function() {
    return this.rotate + "," + this.translate.getAsString();
};
// ======================================
// Polygon class
function Polygon() {
    this.points = new Array(); // a list of Point2D's
};
// --------------------------------------
Polygon.prototype.drawPath = function( ctx ) {
    ctx.beginPath();
    ctx.moveTo( this.points[0].x, this.points[0].y );
    for( var i = 1; i < this.points.length; ++i )
        ctx.lineTo( this.points[i].x, this.points[i].y );
    ctx.closePath();
};
// --------------------------------------
Polygon.prototype.getArea = function() {
    var area=0.0;
    var i, j = this.points.length-1;
    for( i = 0; i < this.points.length; ++i )
    {
        area += ( this.points[j].x + this.points[i].x ) * ( this.points[j].y - this.points[i].y ); 
        j = i;
    }
    return area * 0.5; 
};
// --------------------------------------
function getCircle( center, radius, n )
{
    var poly = new Polygon();
    for( var i = 0; i < n; ++i )
    {
        poly.points[i] = new Point2D( center.x + radius * Math.cos( i * 2.0 * Math.PI / n ), 
                                      center.y + radius * Math.sin( i * 2.0 * Math.PI / n ) );
    }
    return poly;
};
// --------------------------------------
Polygon.prototype.contains = function( p ) {
    var c = false;
    var i, j;
    var vertxi,vertyi,vertxj,vertyj;
    for( i = 0, j = this.points.length-1; i < this.points.length; j = i++ ) 
    {
        vertxi = this.points[i].x;
        vertyi = this.points[i].y;
        vertxj = this.points[j].x;
        vertyj = this.points[j].y;
        if ( ((vertyi>p.y) != (vertyj>p.y)) && (p.x < (vertxj-vertxi) * (p.y-vertyi) / (vertyj-vertyi) + vertxi) )
        {
            c = !c;
        }
    }
    return c;
};
// --------------------------------------
Polygon.prototype.getAsString = function() {
    var spec = this.points.length;
    for( var i = 0; i < this.points.length; ++i )
        spec += "," + this.points[i].getAsString();
    return spec;
};
// --------------------------------------
var PolygonRelationEnum = Object.freeze ({ disjoint: {}, contained: {}, containing: {}, intersecting: {} });
// --------------------------------------
Polygon.prototype.getPolygonRelationWith = function( poly ) {
    for( var i = 0; i < this.points.length; ++i )
    {
        var p = this.points[ i ];
        var p2 = this.points[ (i+1)%this.points.length ];
        for( var j = 0; j < poly.points.length; ++j )
        {
            var q = poly.points[ j ];
            var q2 = poly.points[ (j+1)%poly.points.length ];
            if( lineSegmentsIntersect( p, p2, q, q2 ) )
                return PolygonRelationEnum.intersecting;
        }
    }
    if( poly.contains( this.points[0] ) )
        return PolygonRelationEnum.contained;
    if( this.contains( poly.points[0] ) )
        return PolygonRelationEnum.containing;
    return PolygonRelationEnum.disjoint;
};
// --------------------------------------
Polygon.prototype.getTransformed = function( t ) {
    var poly = new Polygon();
    for( var iPt = 0; iPt < this.points.length; ++iPt )
        poly.points[ iPt ] = t.apply( this.points[ iPt ] );
    return poly;
};
// ======================================
// Piece class
function Piece() {
    this.atOrigin = new Polygon();              // canonical polygon with centroid at the origin
    this.originToTarget = new Array();          // a Transform for each target
    this.isSelected = false;
    this.hue = Math.random() * 360.0;
    this.isGrabbed = false;
    this.whichTargetGrabbed = -1;
    this.whereGrabbed = null;
};
// --------------------------------------
Piece.prototype.draw = function( ctx ) {
    if( this.isSelected )
        ctx.fillStyle = "hsla("+this.hue+",100%,50%,0.8)";
    else
        ctx.fillStyle = "hsla("+this.hue+",80%,50%,0.3)";
    for(var i = 0; i < this.originToTarget.length; ++i ) {
        ctx.save();
        ctx.translate( this.originToTarget[i].translate.x, this.originToTarget[i].translate.y );
        ctx.rotate( this.originToTarget[i].rotate );
        this.atOrigin.drawPath( ctx );
        ctx.fill();
        ctx.restore();
    }
};
// --------------------------------------
Piece.prototype.getAsString = function() {
    var spec = this.atOrigin.getAsString() + "," + this.originToTarget.length + "," + this.hue;
    for( var i = 0; i < this.originToTarget.length; ++i )
        spec += "," + this.originToTarget[i].getAsString();
    return spec;
};
// --------------------------------------
Piece.prototype.getPolygonOnTarget = function( iTarget ) {
    return this.atOrigin.getTransformed( this.originToTarget[ iTarget ] );
};
// --------------------------------------
Piece.prototype.onMouseMove = function( evt ) {
    this.isSelected = false;
    var p = new Point2D( evt.clientX, evt.clientY );
    for( var iTarget = 0; iTarget < this.originToTarget.length; ++iTarget )
    {
        var polygonOnTarget = this.getPolygonOnTarget( iTarget );
        if( polygonOnTarget.contains( p ) )
        {
            this.isSelected = true;
        }
    }
};
// ======================================
// World class
function World() {
    this.circleCenter = new Point2D( 250, 350 );
    this.circleRadius = 200.0;
    
    this.squareCenter = new Point2D( 650, 350 );
    this.squareRadius = this.circleRadius * Math.sqrt( Math.PI ) / 2.0;

    this.targets = new Array();
    
    this.targets[0] = getCircle( this.circleCenter, this.circleRadius, 100 );
    this.targets[1] = new Polygon();
    this.targets[1].points[0] = new Point2D( this.squareCenter.x - this.squareRadius, this.squareCenter.y - this.squareRadius );
    this.targets[1].points[1] = new Point2D( this.squareCenter.x - this.squareRadius, this.squareCenter.y + this.squareRadius );
    this.targets[1].points[2] = new Point2D( this.squareCenter.x + this.squareRadius, this.squareCenter.y + this.squareRadius );
    this.targets[1].points[3] = new Point2D( this.squareCenter.x + this.squareRadius, this.squareCenter.y - this.squareRadius );

    this.pieces = new Array();
    
    var test = this.pieces[0] = new Piece();
    test.atOrigin.points[0] = new Point2D( 34, 10 );
    test.atOrigin.points[1] = new Point2D( -10, -10 );
    test.atOrigin.points[2] = new Point2D( 7, 20 );
    test.originToTarget[0] = new Transform( 0.3, this.circleCenter );
    test.originToTarget[1] = new Transform( 0.6, this.squareCenter );
    
    var test2 = this.pieces[1] = new Piece();
    test2.atOrigin.points[0] = new Point2D( -17, 50 );
    test2.atOrigin.points[1] = new Point2D( 70, 20 );
    test2.atOrigin.points[2] = new Point2D( 34, 10 );
    test2.atOrigin.points[3] = new Point2D( -10, -10 );
    test2.originToTarget[0] = new Transform( 0.7, new Point2D( this.circleCenter.x - 50.0, this.circleCenter.y - 50.0 ) );
    test2.originToTarget[1] = new Transform( 2.8, new Point2D( this.squareCenter.x + 50.0, this.squareCenter.y - 50.0 ) );
};
// --------------------------------------
World.prototype.draw = function( canvas ) {
    var context = canvas.getContext( "2d" );
    
    // draw the background
    context.fillStyle = "rgb(200,200,200)";
    context.beginPath();
    context.fillRect( 0, 0, canvas.width, canvas.height );
    context.closePath();
    
    // draw the targets
    context.fillStyle = "rgb(255,255,255)";
    for( var i = 0; i < this.targets.length; ++i )
    {
        this.targets[i].drawPath( context );
        context.fill();
    }
        
    // draw the pieces
    for( var i = 0; i < this.pieces.length; ++i )
    {
        this.pieces[i].draw( context );
    }
    
    // DEBUG: draw the spec string
    context.fillStyle = "rgb(0,0,0)";
    context.font="12px Arial";
    context.fillText( this.getAsString(), 10, 50 );
    context.fillText( this.pieces.length + " : " + this.getAreaCovered()*100 + "%", 10, 80 );
    if( this.isValidSolution() )
        context.fillText( "valid solution", 10, 110 );
    else
        context.fillText( "overlapping detected!", 10, 110 );
};
// --------------------------------------
World.prototype.isValidSolution = function() {
    var polysOnTarget = new Array();
    for( var iTarget = 0; iTarget < this.targets.length; ++iTarget ) {
        for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece ) {
            // transform each piece onto this target
            polysOnTarget[ iPiece ] = this.pieces[ iPiece ].getPolygonOnTarget( iTarget );
            // invalid if any piece not fully contained in each target
            if( polysOnTarget[ iPiece ].getPolygonRelationWith( this.targets[ iTarget ] ) != PolygonRelationEnum.contained ) 
                return false;
            // invalid if any piece not fully outside any other
            for( var iPiece2 = 0; iPiece2 < iPiece; ++iPiece2 ) 
                if( polysOnTarget[ iPiece ].getPolygonRelationWith( polysOnTarget[ iPiece2 ] ) != PolygonRelationEnum.disjoint ) 
                    return false;
        }
    }
    return true;
};
// --------------------------------------
World.prototype.getAreaCovered = function() {
    // assumes no overlapping
    var area = 0.0;
    for( var i = 0; i < this.pieces.length; ++i )
        area += this.pieces[i].atOrigin.getArea();
    return area / ( Math.PI * this.circleRadius * this.circleRadius );
};
// --------------------------------------
World.prototype.getAsString = function() {
    // targets:
    var spec = this.targets.length + "," + this.circleCenter.getAsString() + "," + this.circleRadius + ","
                + this.squareCenter.getAsString() + "," + this.squareRadius;
                
    // pieces:
    spec += "," + this.pieces.length;
    for( var i = 0; i < this.pieces.length; ++i )
        spec += "," + this.pieces[i].getAsString();
    return spec;
};
// --------------------------------------
World.prototype.onMouseMove = function( evt ) {
    // highlight whichever piece is underneath
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        this.pieces[ iPiece ].onMouseMove( evt );
};
// --------------------------------------
World.prototype.onMouseLeftDown = function( evt ) {
};
// --------------------------------------
World.prototype.onMouseLeftUp = function( evt ) {
};
// --------------------------------------
World.prototype.onMouseLeftDrag = function( evt ) {
    // DEBUG: show something moving
    this.pieces[0].originToTarget[0].translate = new Point2D( evt.clientX, evt.clientY );
};
// ======================================

(function() 
{
    var canvas  = document.getElementById( 'myCanvas' );
    var context = canvas.getContext( '2d' );
    var world   = new World();
    var mouseLeftDown = false;
    
    resizeCanvas();
    
    // events:

    window.addEventListener( 'resize', resizeCanvas, false );
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        world.draw( canvas ); 
    };
    
    canvas.addEventListener( 'mousemove', function( evt ) {
        if( mouseLeftDown )
            world.onMouseLeftDrag( evt );
        else
            world.onMouseMove( evt );
        world.draw( canvas );
      }, false );

    canvas.addEventListener( 'mousedown', function( evt ) {
        if( evt.button == 0 ) {
            mouseLeftDown = true;
            world.onMouseLeftDown( evt );
            world.draw( canvas );
        }
      }, false );

    canvas.addEventListener( 'mouseup', function( evt ) {
        if( evt.button == 0 && mouseLeftDown ) {
            mouseLeftDown = false;
            world.onMouseLeftUp( evt );
            world.draw( canvas );
        }
      }, false );
      
    canvas.addEventListener( 'mouseout', function( evt ) {
        // if user drags the mouse out and then releases we won't receive the mouseUp event,
        // so instead we treat mouseOut as mouseUp (if button is pressed)
        if( mouseLeftDown ) {
            mouseLeftDown = false;
            world.onMouseLeftUp( evt );
            world.draw( canvas );
        }
      }, false );
      
})();
</script> 
</body>
</html>
