<html>
<title>Circle-Squaring</title>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<style>
* { margin:0; padding:0; } /* to remove the top and left whitespace */
html, body { width:100%; height:100%; } /* just to be sure these are full screen*/
canvas { display:block; } /* To remove the scrollbars */
</style>
<script src="https://cdn.firebase.com/v0/firebase.js"></script>
</head>
<body>
<canvas id="myCanvas"></canvas> 
<script>
// ======================================
// utility functions
function crossProduct2D( v, w ) { return v.x*w.y - v.y*w.x; }
// --------------------------------------
function add( a, b ) { return new Point2D( a.x + b.x, a.y + b.y ); }
// --------------------------------------
function sub( a, b ) { return new Point2D( a.x - b.x, a.y - b.y ); }
// --------------------------------------
function sqr( x ) { return x * x }
// --------------------------------------
function dist2( v, w ) { return sqr(v.x - w.x) + sqr(v.y - w.y) }
// --------------------------------------
function distToSegmentSquared( p, v, w ) {
  var l2 = dist2(v, w);
  if (l2 == 0) return dist2(p, v);
  var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
  if (t < 0) return dist2(p, v);
  if (t > 1) return dist2(p, w);
  return dist2(p, { x: v.x + t * (w.x - v.x),
                    y: v.y + t * (w.y - v.y) });
}
// --------------------------------------
function distToSegment( p, v, w ) { return Math.sqrt(distToSegmentSquared(p, v, w)); }
// --------------------------------------
function lineSegmentsIntersect( p, p2, q, q2 ) {
    // two line segments: [p,p2] and [q,q2] - do they intersect?
    // http://stackoverflow.com/a/565282/126823
    var r = sub(p2, p);
    var s = sub(q2, q);

    var uNumerator = crossProduct2D(sub(q, p), r);
    var denominator = crossProduct2D(r, s);

    if( uNumerator == 0 && denominator == 0 ) {
        // colinear, so do they overlap?
        return ((q.x - p.x < 0) != (q.x - p2.x < 0) != (q2.x - p.x < 0) != (q2.x - p2.x < 0)) ||
                ((q.y - p.y < 0) != (q.y - p2.y < 0) != (q2.y - p.y < 0) != (q2.y - p2.y < 0));
    }

    if( denominator == 0 ) {
        // lines are parallel
        return false;
    }

    var u = uNumerator / denominator;
    var t = crossProduct2D(sub(q, p), s) / denominator;

    return (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);
}
// --------------------------------------
function dot( a, b ) {
    return a.x * b.x + a.y * b.y;
}
// --------------------------------------
function angleBetweenTwoVectors( a, b ) {
    return Math.acos( dot( a, b ) / ( a.len() * b.len() ) );
}
// ======================================
// Point2D class
function Point2D( x, y ) {
    this.x = x;
    this.y = y;
};
// --------------------------------------
Point2D.prototype.add = function( p ) {
    this.x += p.x;
    this.y += p.y;
    return this;
};
// --------------------------------------
Point2D.prototype.sub = function( p ) {
    this.x -= p.x;
    this.y -= p.y;
    return this;
};
// --------------------------------------
Point2D.prototype.mul = function( f ) {
    this.x *= f;
    this.y *= f;
    return this;
};
// --------------------------------------
Point2D.prototype.div = function( f ) {
    this.x /= f;
    this.y /= f;
    return this;
};
// --------------------------------------
Point2D.prototype.dist = function( p ) {
    return Math.sqrt( sqr( this.x - p.x ) + sqr( this.y - p.y ) );
};
// --------------------------------------
Point2D.prototype.len = function() {
    return Math.sqrt( sqr( this.x ) + sqr( this.y ) );
}
// --------------------------------------
Point2D.prototype.normalize = function() {
    return this.div( this.len() );
};
// ======================================
// Transform class
function Transform( r, p ) {
    this.rotate = r;                             // radians
    this.translate = new Point2D( p.x, p.y );    // Point2D
};
// --------------------------------------
Transform.prototype.apply = function( p ) {
    return new Point2D( p.x * Math.cos( this.rotate ) - p.y * Math.sin( this.rotate ) + this.translate.x, 
                        p.x * Math.sin( this.rotate ) + p.y * Math.cos( this.rotate ) + this.translate.y );
};
// --------------------------------------
Transform.prototype.applyInverse = function( p ) {
    return new Point2D( ( p.x - this.translate.x ) * Math.cos( -this.rotate ) - ( p.y - this.translate.y ) * Math.sin( -this.rotate ), 
                        ( p.x - this.translate.x ) * Math.sin( -this.rotate ) + ( p.y - this.translate.y ) * Math.cos( -this.rotate ) );
};
// ======================================
// Polygon class
function Polygon() {
    this.points = new Array(); // a list of Point2D's
};
// --------------------------------------
Polygon.prototype.drawPath = function( ctx ) {
    if( this.points.length == 0 ) 
        return;
    ctx.beginPath();
    ctx.moveTo( this.points[0].x, this.points[0].y );
    for( var i = 1; i < this.points.length; ++i )
        ctx.lineTo( this.points[i].x, this.points[i].y );
    ctx.closePath();
};
// --------------------------------------
Polygon.prototype.getArea = function() {
    var area=0.0;
    var i, j = this.points.length-1;
    for( i = 0; i < this.points.length; ++i )
    {
        area += ( this.points[j].x + this.points[i].x ) * ( this.points[j].y - this.points[i].y ); 
        j = i;
    }
    return area * 0.5; 
};
// --------------------------------------
Polygon.prototype.getCentroid = function() {
    var centroid = new Point2D( 0, 0 );
    for( var i = 0; i < this.points.length; ++i )
        centroid.add( this.points[ i ] );
    return centroid.div( this.points.length ); 
};
// --------------------------------------
function getCircle( center, radius, n )
{
    var poly = new Polygon();
    for( var i = 0; i < n; ++i )
    {
        poly.points[i] = new Point2D( center.x + radius * Math.cos( i * 2.0 * Math.PI / n ), 
                                      center.y - radius * Math.sin( i * 2.0 * Math.PI / n ) );
    }
    return poly;
};
// --------------------------------------
Polygon.prototype.contains = function( p ) {
    var c = false;
    var i, j;
    var vertxi,vertyi,vertxj,vertyj;
    for( i = 0, j = this.points.length-1; i < this.points.length; j = i++ ) 
    {
        vertxi = this.points[i].x;
        vertyi = this.points[i].y;
        vertxj = this.points[j].x;
        vertyj = this.points[j].y;
        if ( ((vertyi>p.y) != (vertyj>p.y)) && (p.x < (vertxj-vertxi) * (p.y-vertyi) / (vertyj-vertyi) + vertxi) )
        {
            c = !c;
        }
    }
    return c;
};
// --------------------------------------
Polygon.prototype.doesLineSegmentIntersect = function( p, p2 ) {
    for( var i = 0; i < this.points.length; ++i )
    {
        var q = this.points[ i ];
        var q2 = this.points[ (i+1)%this.points.length ];
        if( lineSegmentsIntersect( p, p2, q, q2 ) )
            return true;
    }
    return false;
};
// --------------------------------------
var PolygonRelationEnum = Object.freeze ({ disjoint: {}, contained: {}, containing: {}, intersecting: {} });
// --------------------------------------
Polygon.prototype.getPolygonRelationWith = function( poly ) {
    for( var i = 0; i < this.points.length; ++i )
    {
        var p = this.points[ i ];
        var p2 = this.points[ (i+1)%this.points.length ];
        for( var j = 0; j < poly.points.length; ++j )
        {
            var q = poly.points[ j ];
            var q2 = poly.points[ (j+1)%poly.points.length ];
            if( lineSegmentsIntersect( p, p2, q, q2 ) )
                return PolygonRelationEnum.intersecting;
        }
    }
    if( poly.contains( this.points[0] ) )
        return PolygonRelationEnum.contained;
    if( this.contains( poly.points[0] ) )
        return PolygonRelationEnum.containing;
    return PolygonRelationEnum.disjoint;
};
// --------------------------------------
Polygon.prototype.getTransformed = function( t ) {
    var poly = new Polygon();
    for( var iPt = 0; iPt < this.points.length; ++iPt )
        poly.points[ iPt ] = t.apply( this.points[ iPt ] );
    return poly;
};
// --------------------------------------
Polygon.prototype.isPointNearEdge = function( p, tol ) {
    for( var iPt = 0; iPt < this.points.length; ++iPt )
        if( distToSegment( p, this.points[iPt], this.points[ (iPt+1)%this.points.length ] ) < tol )
            return true;
    return false;
};
// --------------------------------------
Polygon.prototype.getNormal = function( iPt ) {
    // return average of two neighboring edge normals
    var a = this.points[ (iPt+this.points.length-1)%this.points.length ];
    var b = this.points[ iPt ];
    var c = this.points[ (iPt+1)%this.points.length ];
    var e1 = sub( b, a );
    var en1 = new Point2D( -e1.y, e1.x ).normalize();
    var e2 = sub( c, b );
    var en2 = new Point2D( -e2.y, e2.x ).normalize();
    var n = add( en1, en2 ).normalize();
    return n;
};
// --------------------------------------
Polygon.prototype.isSelfIntersecting = function() {
    // does any line segment cross any other?
    for( var iPt = 0; iPt < this.points.length; ++iPt )
    {
        var iP1 = iPt;
        var iP2 = (iPt+1)%this.points.length;
        var p1 = this.points[ iP1 ];
        var p2 = this.points[ iP2 ];
        for( var iPt2 = 0; iPt2 < iPt-1; ++iPt2 )
        {
            var iQ1 = iPt2;
            var iQ2 = (iPt2+1)%this.points.length;
            if( iQ1 == iP2 || iQ2 == iP1 )
                continue; // neighboring edges, ignore
            var q1 = this.points[ iQ1 ];
            var q2 = this.points[ iQ2 ];
            if( lineSegmentsIntersect( p1, p2, q1, q2 ) )
                return true;
        }
    }
    return false;
};
// ======================================
// Piece class
// --------------------------------------
var PieceStateEnum = Object.freeze ({ inactive: {}, highlighted: {}, selected: {}, translating: {}, vertexDragging: {}, rotating: {} });
// --------------------------------------
function Piece() {
    this.atOrigin = new Polygon();              // canonical polygon with centroid at the origin
    this.originToTarget = new Array();          // a Transform for each target
    this.state = PieceStateEnum.inactive;
    this.iActiveVertex = -1;
    this.whichTargetSelected = -1;
    this.draggingPoint = null;
    this.hue = Math.random() * 360.0;
    this.vertexRadius = 5;
};
// --------------------------------------
Piece.prototype.isSelected = function() {
    return this.state != PieceStateEnum.inactive && this.state != PieceStateEnum.highlighted;
}
// --------------------------------------
Piece.prototype.draw = function( ctx ) {
    // draw the pieces on each target
    ctx.strokeStyle = "rgb(0,0,0)";
    ctx.lineWidth = 1;
    for(var iTarget = 0; iTarget < this.originToTarget.length; ++iTarget ) 
    {
        ctx.save();
        if( this.state != PieceStateEnum.inactive )
            ctx.fillStyle = "hsla("+this.hue+",100%,50%,0.8)";
        else
            ctx.fillStyle = "hsla("+this.hue+",80%,50%,0.3)";
        ctx.translate( this.originToTarget[ iTarget ].translate.x, this.originToTarget[ iTarget ].translate.y );
        ctx.rotate( this.originToTarget[ iTarget ].rotate );
        this.atOrigin.drawPath( ctx );
        ctx.fill();
        if( this.isSelected() ) 
        {
            ctx.stroke();
            // draw vertex handles
            ctx.fillStyle = "rgba(0,0,0,0.4)";
            for( var iVert = 0; iVert < this.atOrigin.points.length; ++iVert ) {
                ctx.beginPath();
                ctx.arc( this.atOrigin.points[ iVert ].x, this.atOrigin.points[ iVert ].y, this.vertexRadius, 0, 2*Math.PI );
                ctx.fill();
                if( this.state == PieceStateEnum.vertexDragging && this.iActiveVertex == iVert )
                    ctx.stroke();
                ctx.closePath();
            }
        }
        ctx.restore();
    }
    // draw the cursor
    if( this.state == PieceStateEnum.rotating ) {
        // draw a broken circle to show that piece can be rotated like this
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = this.vertexRadius;
        var arcRadius = this.vertexRadius*2;
        ctx.beginPath();
        var pOnTarget = this.originToTarget[ this.whichTargetSelected ].apply( this.draggingPoint );
        ctx.arc( pOnTarget.x, pOnTarget.y, arcRadius, 0, 1.8 * Math.PI );
        ctx.stroke();
        ctx.closePath();
        // also draw the center of rotation
        var center = this.originToTarget[ this.whichTargetSelected ].apply( new Point2D( 0, 0 ) );
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.lineWidth = 1;
        var crossWidth = this.vertexRadius/2;
        ctx.beginPath();
        ctx.moveTo( center.x - crossWidth, center.y )
        ctx.lineTo( center.x + crossWidth, center.y )
        ctx.moveTo( center.x, center.y - crossWidth )
        ctx.lineTo( center.x, center.y + crossWidth )
        ctx.stroke();
        ctx.closePath();
    }
    else if( this.state == PieceStateEnum.translating || this.state == PieceStateEnum.highlighted ) {
        // draw a cross to show that piece can be moved like this
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = this.vertexRadius;
        var crossWidth = this.vertexRadius*2;
        ctx.beginPath();
        ctx.moveTo( this.draggingPoint.x - crossWidth, this.draggingPoint.y )
        ctx.lineTo( this.draggingPoint.x + crossWidth, this.draggingPoint.y )
        ctx.moveTo( this.draggingPoint.x, this.draggingPoint.y - crossWidth )
        ctx.lineTo( this.draggingPoint.x, this.draggingPoint.y + crossWidth )
        ctx.stroke();
        ctx.closePath();
    }
};
// --------------------------------------
Piece.prototype.getPolygonOnTarget = function( iTarget ) {
    return this.atOrigin.getTransformed( this.originToTarget[ iTarget ] ); // TODO: cache this, only update when needed
};
// --------------------------------------
Piece.prototype.recenter = function() {
    var center = this.atOrigin.getCentroid();
    for( var iPt = 0; iPt < this.atOrigin.points.length; ++iPt )
        this.atOrigin.points[ iPt ].sub( center );
    for( var iTarget = 0; iTarget < this.originToTarget.length; ++iTarget )
        this.originToTarget[ iTarget ].translate = this.originToTarget[ iTarget ].apply( center );
};
// --------------------------------------
Piece.prototype.onMouseMove = function( evt ) {
    var mousePos = new Point2D( evt.clientX, evt.clientY );
    // selected -> selected, translating, rotating or vertexDragging
    if( this.isSelected() )
    {
        for( var iTarget = 0; iTarget < this.originToTarget.length; ++iTarget ) 
        {
            var pAtOrigin = this.originToTarget[ iTarget ].applyInverse( mousePos );
        
            // in position for vertex dragging?
            for( var iVert = 0; iVert < this.atOrigin.points.length; ++iVert ) {
                if( pAtOrigin.dist( this.atOrigin.points[ iVert ] ) < this.vertexRadius ) {
                    this.state = PieceStateEnum.vertexDragging;
                    this.iActiveVertex = iVert;
                    this.draggingPoint = pAtOrigin;
                    this.whichTargetSelected = iTarget;
                    return;
                }
            }
            // in position for rotating the piece?
            if( this.atOrigin.isPointNearEdge( pAtOrigin, this.vertexRadius*2 ) ) {
                this.state = PieceStateEnum.rotating;
                this.draggingPoint = pAtOrigin;
                this.whichTargetSelected = iTarget;
                return;
            }
            // in position for translating the piece?
            if( this.atOrigin.contains( pAtOrigin ) ) {
                this.state = PieceStateEnum.translating;
                this.draggingPoint = mousePos;
                this.whichTargetSelected = iTarget;
                return;
            }
        }
        this.state = PieceStateEnum.selected;
        this.whichTargetSelected = -1;
        return;
    }
    // inactive or highlighted
    for( var iTarget = 0; iTarget < this.originToTarget.length; ++iTarget )
    {
        var pAtOrigin = this.originToTarget[ iTarget ].applyInverse( mousePos );
        if( this.atOrigin.contains( pAtOrigin ) )
        {
            this.state = PieceStateEnum.highlighted;
            this.draggingPoint = mousePos;
            this.whichTargetSelected = iTarget;
            return;
        }
    }
    this.state = PieceStateEnum.inactive;
    this.whichTargetSelected = -1;
};
// --------------------------------------
Piece.prototype.onMouseLeftDown = function( evt ) {
    switch( this.state )
    {
        case PieceStateEnum.selected:
            this.state = PieceStateEnum.inactive;
            return false;
            
        case PieceStateEnum.highlighted:
            this.state = PieceStateEnum.translating;
            return true; // no other piece should get this mouse click
            
        case PieceStateEnum.inactive:
            return false;
            
        default:
            return true; // translating/rotating/vertexDraggging is happening, no other piece should get this mouse click
    }
};
// --------------------------------------
Piece.prototype.onMouseLeftDrag = function( evt ) {
    var mousePos = new Point2D( evt.clientX, evt.clientY );
    switch( this.state ) 
    {
        case PieceStateEnum.vertexDragging:
            var pAtOrigin = this.originToTarget[ this.whichTargetSelected ].applyInverse( mousePos );
            this.atOrigin.points[ this.iActiveVertex ].add( sub( pAtOrigin, this.draggingPoint ) );
            this.recenter();
            this.draggingPoint = this.originToTarget[ this.whichTargetSelected ].applyInverse( mousePos ); // need to recompute because transform has changed
            break;
            
        case PieceStateEnum.translating:
            this.originToTarget[ this.whichTargetSelected ].translate.add( sub( mousePos, this.draggingPoint ) );
            this.draggingPoint = mousePos;
            break;
            
        case PieceStateEnum.rotating:
            var pAtOrigin = this.originToTarget[ this.whichTargetSelected].applyInverse( mousePos );
            this.originToTarget[ this.whichTargetSelected ].rotate += Math.atan2( pAtOrigin.y, pAtOrigin.x ) - Math.atan2( this.draggingPoint.y, this.draggingPoint.x );
            this.draggingPoint = this.originToTarget[ this.whichTargetSelected].applyInverse( mousePos ); // need to recompute because transform has changed
            break;
    }
};
// --------------------------------------
Piece.prototype.removeVertex = function( iPt ) {
    this.atOrigin.points.splice( iPt, 1 );
    if( this.state == PieceStateEnum.vertexDragging ) {
        if( this.iActiveVertex == iPt ) {
            this.state = PieceStateEnum.selected;
            this.iActiveVertex = -1;
        }
        else if( this.iActiveVertex > iPt ) {
            this.iActiveVertex--;
        }
    }
};
// --------------------------------------
Piece.prototype.subdivide = function( minEdgeLength ) {
    var newPoints = new Array();
    var newActiveVertex = -1;
    for( var iOldPt = 0; iOldPt < this.atOrigin.points.length; ++iOldPt )
    {
        newPoints.push( this.atOrigin.points[ iOldPt ] );
        if( this.state == PieceStateEnum.vertexDragging && this.iActiveVertex == iOldPt )
            newActiveVertex = newPoints.length-1;
        if( this.atOrigin.points[ iOldPt ].dist( this.atOrigin.points[ (iOldPt+1)%this.atOrigin.points.length ] ) > minEdgeLength )
            newPoints.push( add( this.atOrigin.points[ iOldPt ], this.atOrigin.points[ (iOldPt+1)%this.atOrigin.points.length ] ).div( 2.0 ) );
    }
    if( this.state == PieceStateEnum.vertexDragging )
        this.iActiveVertex = newActiveVertex;
    this.atOrigin.points = newPoints;
};
// --------------------------------------
Piece.prototype.removeVerticesCloserThan = function( minEdgeLength ) {
    do {
        var removedOne = false;
        for( var iPt = 0; iPt < this.atOrigin.points.length; ++iPt )
        {
            if( this.atOrigin.points[ iPt ].dist( this.atOrigin.points[ (iPt+1)%this.atOrigin.points.length ] ) < minEdgeLength ) {
                this.removeVertex( iPt );
                removedOne = true;
                break;
            }
        }
    } while( removedOne );
};
// --------------------------------------
Piece.prototype.removeVerticesStraighterThan = function( minAngle ) {
    do {
        var removedOne = false;
        for( var iPt = 0; iPt < this.atOrigin.points.length; ++iPt )
        {
            var edge1 = sub( this.atOrigin.points[ iPt ], this.atOrigin.points[ (iPt+1)%this.atOrigin.points.length ] );
            var edge2 = sub( this.atOrigin.points[ (iPt+this.atOrigin.points.length-1)%this.atOrigin.points.length ], this.atOrigin.points[ iPt ]  );
            if( angleBetweenTwoVectors( edge1, edge2 ) < minAngle ) {
                this.removeVertex( iPt );
                removedOne = true;
                break;
            }
        }
    } while( removedOne );
};
// --------------------------------------
Piece.prototype.removeSelfIntersectingVertices = function() {
    // does any line segment cross any other?
    for( var iPt = this.atOrigin.points.length-1; iPt >= 0; --iPt )
    {
        var iP1 = iPt;
        var iP2 = (iPt+1)%this.atOrigin.points.length;
        var p1 = this.atOrigin.points[ iP1 ];
        var p2 = this.atOrigin.points[ iP2 ];
        for( var iPt2 = 0; iPt2 < iPt-1; ++iPt2 )
        {
            var iQ1 = iPt2;
            var iQ2 = (iPt2+1)%this.atOrigin.points.length;
            if( iQ1 == iP2 || iQ2 == iP1 )
                continue; // neighboring edges, ignore
            var q1 = this.atOrigin.points[ iQ1 ];
            var q2 = this.atOrigin.points[ iQ2 ];
            if( lineSegmentsIntersect( p1, p2, q1, q2 ) ) {
                this.removeVertex( iPt );
                break;
            }
        }
    }
};
// ======================================
// Button class
function Button( label, id, x, y, ctx ) {
    this.polygon = new Polygon();
    this.shadowPolygon = new Polygon();
    this.label = label;
    this.id = id;
    this.isEnabled = false;
    this.isPressed = false;
    // initialise a rectangle around the text
    this.fontHeight = 14;
    ctx.font = this.fontHeight + "px Arial";
    var textbox = ctx.measureText( label );
    var pad = 5;
    var shadowOffset = 4;
    this.polygon.points[0] = new Point2D( x, y - this.fontHeight/2 - pad );
    this.polygon.points[1] = new Point2D( x + textbox.width + pad*2, y - this.fontHeight/2 - pad );
    this.polygon.points[2] = new Point2D( x + textbox.width + pad*2, y + this.fontHeight/2 + pad*2 );
    this.polygon.points[3] = new Point2D( x, y + this.fontHeight/2 + pad*2 );
    this.textPos = new Point2D( this.polygon.points[3].x + pad, this.polygon.points[3].y - pad*2 )
    // make a shadow below and to the right
    for( var i = 0; i < this.polygon.points.length; ++i )
        this.shadowPolygon.points[ i ] = add( this.polygon.points[ i ], new Point2D( shadowOffset, shadowOffset ) );
};
// --------------------------------------
Button.prototype.getWidth = function() {
    return this.polygon.points[1].x - this.polygon.points[0].x;
};
// --------------------------------------
Button.prototype.setWidth = function( width ) {
    var deltaWidth = width - this.getWidth();
    this.polygon.points[1].x += deltaWidth;
    this.polygon.points[2].x += deltaWidth;
    this.shadowPolygon.points[1].x += deltaWidth;
    this.shadowPolygon.points[2].x += deltaWidth;
};
// --------------------------------------
Button.prototype.draw = function( ctx ) {
    this.shadowPolygon.drawPath( ctx );
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.fill();
    this.polygon.drawPath( ctx );
    if( !this.isEnabled )
        ctx.fillStyle = "rgb(230,230,230)";
    else if( this.isPressed )
        ctx.fillStyle = "rgb(255,255,255)";
    else
        ctx.fillStyle = "rgb(111,202,255)";
    ctx.fill();
    ctx.font = this.fontHeight + "px Arial";
    if( this.isEnabled )
        ctx.fillStyle = "rgb(0,0,0)";
    else
        ctx.fillStyle = "rgb(200,200,200)";
    ctx.fillText( this.label, this.textPos.x, this.textPos.y );
};
// --------------------------------------
Button.prototype.onMouseLeftDown = function( evt ) {
    if( !this.isEnabled )
        return false;
    var mousePos = new Point2D( evt.clientX, evt.clientY );
    if( this.polygon.contains( mousePos ) ) {
        this.isPressed = true;
        return true;
    }
    return false;
};
// --------------------------------------
Button.prototype.onMouseLeftUp = function( evt ) {
    this.isPressed = false;
};
// ======================================
// World class
function World( context ) {
    this.isAutoEnabled = true;

    this.circleCenter = new Point2D( 250, 350 );
    this.circleRadius = 200.0;
    
    this.squareCenter = new Point2D( 650, 350 );
    this.squareRadius = this.circleRadius * Math.sqrt( Math.PI ) / 2.0;

    this.targets = new Array();
    
    this.targets[0] = getCircle( this.circleCenter, this.circleRadius, 100 );
    this.targets[1] = new Polygon();
    this.targets[1].points[0] = new Point2D( this.squareCenter.x - this.squareRadius, this.squareCenter.y - this.squareRadius );
    this.targets[1].points[1] = new Point2D( this.squareCenter.x - this.squareRadius, this.squareCenter.y + this.squareRadius );
    this.targets[1].points[2] = new Point2D( this.squareCenter.x + this.squareRadius, this.squareCenter.y + this.squareRadius );
    this.targets[1].points[3] = new Point2D( this.squareCenter.x + this.squareRadius, this.squareCenter.y - this.squareRadius );
    
    this.leaderboard = new Array();

    this.username = "anon" + Math.floor(Math.random()*9000+1000);
    
    this.pieces = new Array();
   
    // make some pieces
    var nPieces = Math.floor( Math.random()*3 ) + 4 ;
    var scatterRadius = this.circleRadius * 0.7;
    for( var iPiece = 0; iPiece < nPieces; ++iPiece ) {
        var piece = this.pieces[ iPiece ] = new Piece();
        piece.atOrigin = getCircle( new Point2D( 0, 0 ), Math.random()*20+20, Math.floor(Math.random()*4)+3 );
        for( var iTarget = 0; iTarget < this.targets.length; ++iTarget )
            piece.originToTarget[ iTarget ] = new Transform( Math.random()*2.0*Math.PI, add( this.targets[ iTarget ].getCentroid(), 
                                                             new Point2D( Math.random()*scatterRadius*2-scatterRadius,
                                                                          Math.random()*scatterRadius*2-scatterRadius ) ) );
    }
    
    this.buttons = new Array();
    
    var buttonX = 15;
    var buttonSep = 10;
    this.deletePieceButton = this.buttons[0] = new Button( "Delete piece", "delete_piece", buttonX, 20, context );
    buttonX += this.buttons[0].getWidth() + buttonSep;
    this.newPieceButton = this.buttons[1] = new Button( "New piece", "new_piece", buttonX, 20, context );
    buttonX += this.buttons[1].getWidth() + buttonSep;
    this.automaticToggleButton = this.buttons[2] = new Button("Go manual", "toggle_auto", buttonX, 20, context );
    buttonX += this.buttons[2].getWidth() + buttonSep;
    this.automaticToggleButton.isEnabled = true;
    this.submitSolutionButton = this.buttons[3] = new Button("Submit solution", "submit_solution", buttonX, 20, context );
    buttonX += this.buttons[3].getWidth() + buttonSep;
    this.buttons[7] = new Button("Save solution", "save_solution", buttonX, 20, context );
    this.buttons[7].isEnabled = true;
    buttonX += this.buttons[7].getWidth() + buttonSep;
    this.buttons[8] = new Button("Load solution", "load_solution", buttonX, 20, context );
    this.buttons[8].isEnabled = true;
    buttonX = 15;
    this.clonePieceButton = this.buttons[4] = new Button("Clone piece", "clone_piece", buttonX, 60, context );
    buttonX += this.buttons[4].getWidth() + buttonSep;
    this.subdividePieceButton = this.buttons[5] = new Button("Subdivide piece", "subdivide_piece", buttonX, 60, context );
    buttonX += this.buttons[5].getWidth() + buttonSep;
    this.simplifyPieceButton = this.buttons[6] = new Button("Simplify piece", "simplify_piece", buttonX, 60, context );

    for( var N = 1; N <= 10; ++N ) {
        this.buttons.push( new Button( "N="+N+" : unknown", "leaderboard", 900, 70+N*40, context ) );
        this.buttons[ this.buttons.length-1 ].setWidth( 200 );
        if( N==1 )
            this.iFirstLeaderboardButton = this.buttons.length-1;
    }

    // we keep track of new results as they come in
    this.updates = new Array();
};
// --------------------------------------
World.prototype.draw = function( canvas ) {
    var context = canvas.getContext( "2d" );
    var isValidSolution = this.isValidSolution();
    
    // draw the background
    context.fillStyle = "rgb(200,200,200)";
    context.beginPath();
    context.fillRect( 0, 0, canvas.width, canvas.height );
    context.closePath();
    
    // update the buttons
    this.simplifyPieceButton.isEnabled = this.subdividePieceButton.isEnabled = this.clonePieceButton.isEnabled = this.deletePieceButton.isEnabled = this.isAnyPieceSelected();
    this.newPieceButton.isEnabled = !this.isAutoEnabled;
    var isCurrentBest = false;
    if( this.pieces.length <1 || this.pieces.length >10 )
        isCurrentBest = false;
    else if( isValidSolution && this.leaderboard[ this.pieces.length ] && this.getPercentCovered() > this.leaderboard[ this.pieces.length ].percent+0.01 )
        isCurrentBest = true;
    else if( isValidSolution && typeof this.leaderboard[ this.pieces.length ] == "undefined" )
        isCurrentBest = true;
    this.submitSolutionButton.isEnabled = (this.updates.length > 0) && isCurrentBest;
    
    // draw the buttons
    for( var iButton = 0; iButton < this.buttons.length; ++iButton )
        this.buttons[ iButton ].draw( context );
        
    // draw the targets
    context.fillStyle = "rgb(255,255,255)";
    for( var i = 0; i < this.targets.length; ++i ) {
        this.targets[i].drawPath( context );
        context.fill();
    }
        
    // draw the pieces (in reverse order so that the transparency appearance matches the selection behavior)
    for( var iPiece = this.pieces.length - 1; iPiece >= 0; --iPiece )
        this.pieces[ iPiece ].draw( context );
    
    // show some information about the current pieces
    context.fillStyle = "rgb(0,0,0)";
    context.font="12px Arial";
    var percentageCoverage = this.getPercentCovered();
    context.fillText( 'N = ' + this.pieces.length + " : " + percentageCoverage.toFixed(2) + "% coverage", 10, 100 );
    if( isValidSolution )
        context.fillText( "valid solution (no overlapping)", 10, 130 );
    else
        context.fillText( "overlapping detected!", 10, 130 );
        
    // show the last few updates that have been happening
    var numUpdatesToShow = Math.min( 5, this.updates.length );
    var timeNow = new Date();
    for( var i = 0; i < numUpdatesToShow; ++i ) {
        var update = this.updates[ i ]
        var msPerMinute = 1000*60;
        var minuteDifference = ( timeNow.getTime() - update.time.getTime() ) / msPerMinute
        var hourDifference = minuteDifference/60;
        var dayDifference = hourDifference/24;
        var yearDifference = dayDifference/365;
        var timeDiff = "";
        if( minuteDifference < 60 )
            timeDiff = minuteDifference.toFixed(0) + " minute(s) ago: ";
        else if( hourDifference < 24 )
            timeDiff = hourDifference.toFixed(0) + " hour(s) ago: ";
        else if( dayDifference < 365 )
            timeDiff = dayDifference.toFixed(0) + " day(s) ago: ";
        else
            timeDiff = yearDifference.toFixed(0) + " year(s) ago: ";
        context.fillText( timeDiff + update.text, 10, 700 - 20*i );
    }
    if( this.updates.length > 0 )
        context.fillText( "Most recent of " + this.updates.length + " events:", 10, 700 - 20*numUpdatesToShow );
    else
        context.fillText( "Loading leaderboard...", 10, 700 - 20*numUpdatesToShow );
};
// --------------------------------------
World.prototype.isPointInsideTarget = function( point, iTarget ) {
    switch( iTarget ) {
        case 0: return( dist2( point, this.circleCenter ) < sqr( this.circleRadius ) );
        default: return( this.targets[ iTarget ].contains( point ) );
    }
};
// --------------------------------------
World.prototype.isPolygonInsideTarget = function( polygon, iTarget ) {
    // simply check that all vertices are inside (assumes targets are convex)
    for( var iPt = 0; iPt < polygon.points.length; ++iPt )
        if( !this.isPointInsideTarget( polygon.points[ iPt ], iTarget ) )
            return false;
    return true;
};
// --------------------------------------
World.prototype.isValidSolution = function() {
    var polysOnTarget = new Array();
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece ) {
        // polygon must not be self-intersecting
        if( this.pieces[ iPiece ].atOrigin.isSelfIntersecting() )
            return false;
        // polygon must be clockwise (positive area)
        if( this.pieces[ iPiece ].atOrigin.getArea() <= 0 )
            return false;
    }
    for( var iTarget = 0; iTarget < this.targets.length; ++iTarget ) {
        for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece ) {
            // transform each piece onto this target
            polysOnTarget[ iPiece ] = this.pieces[ iPiece ].getPolygonOnTarget( iTarget );
            // invalid if any piece not fully contained in each target
            if( !this.isPolygonInsideTarget( polysOnTarget[ iPiece ], iTarget ) ) 
                return false;
            // invalid if any piece not fully outside any other
            for( var iPiece2 = 0; iPiece2 < iPiece; ++iPiece2 ) 
                if( polysOnTarget[ iPiece ].getPolygonRelationWith( polysOnTarget[ iPiece2 ] ) != PolygonRelationEnum.disjoint ) 
                    return false;
        }
    }
    return true;
};
// --------------------------------------
World.prototype.getPercentCovered = function() {
    // assumes no overlapping
    var area = 0.0;
    for( var i = 0; i < this.pieces.length; ++i )
        area += this.pieces[i].atOrigin.getArea();
    return 100.0 * area / ( Math.PI * this.circleRadius * this.circleRadius );
};
// --------------------------------------
World.prototype.addNewPiece = function() {
    var p = new Piece();
    p.atOrigin = getCircle( new Point2D( 0, 0 ), 30, 6 );
    for( var iTarget = 0; iTarget < this.targets.length; ++iTarget )
        p.originToTarget[ iTarget ] = new Transform( Math.random() * 2.0 * Math.PI, this.targets[ iTarget ].getCentroid() );
    this.pieces.unshift( p ); // add to start of list, so it appears on top
};
// --------------------------------------
World.prototype.deleteSelectedPiece = function() {
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        if( this.pieces[ iPiece ].isSelected() )
            this.pieces.splice( iPiece, 1 );
};
// --------------------------------------
World.prototype.cloneSelectedPiece = function() {
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        if( this.pieces[ iPiece ].isSelected() )
            var sourcePiece = this.pieces[ iPiece ];
    var p = new Piece();
    for( var iPt = 0; iPt < sourcePiece.atOrigin.points.length; ++iPt )
        p.atOrigin.points[ iPt ] = new Point2D( sourcePiece.atOrigin.points[ iPt ].x, sourcePiece.atOrigin.points[ iPt ].y );
    for( var iTarget = 0; iTarget < sourcePiece.originToTarget.length; ++iTarget )
        p.originToTarget[ iTarget ] = new Transform( sourcePiece.originToTarget[ iTarget ].rotate, sourcePiece.originToTarget[ iTarget ].translate );
    sourcePiece.state = PieceStateEnum.inactive;
    this.pieces.unshift( p ); // add to start of list, so it appears on top
};
// --------------------------------------
World.prototype.clipPiecesAgainstTargets = function() {
    for( var iPiece = this.pieces.length-1; iPiece >=0; --iPiece ) 
    {
        var piece = this.pieces[ iPiece ];
        var pieceDeleted = false;
        for( var iTarget = 0; iTarget < piece.originToTarget.length; ++iTarget ) 
        {
            var polygonOnTarget = piece.getPolygonOnTarget( iTarget );
            for( iPt = polygonOnTarget.points.length-1; iPt >= 0; --iPt ) 
            {
                if( !this.isPointInsideTarget( polygonOnTarget.points[ iPt ], iTarget ) )
                {
                    piece.removeVertex( iPt );
                    if( piece.atOrigin.points.length < 3 )
                    {
                        this.pieces.splice( iPiece, 1 );
                        pieceDeleted = true;
                        break;
                    }
                }
            }
            if( pieceDeleted )
                break;
        }
    }
};
// --------------------------------------
World.prototype.clipPiecesAgainstOthers = function() {
    for( var iPiece = this.pieces.length-1; iPiece >=0; --iPiece ) 
    {
        var piece = this.pieces[ iPiece ];
        if( piece.isSelected() )
            continue; // don't clip the piece that is currently selected (feels more natural when changing it in auto mode)
        var pieceDeleted = false;
        for( var iTarget = 0; iTarget < this.targets.length; ++iTarget )
        {
            var polygonOnTarget = piece.getPolygonOnTarget( iTarget );
            for( var iOtherPiece = 0; iOtherPiece < this.pieces.length; ++iOtherPiece ) 
            {
                if( iOtherPiece == iPiece )
                    continue;
                var otherPolygonOnTarget = this.pieces[ iOtherPiece ].getPolygonOnTarget( iTarget );
                for( iPt = polygonOnTarget.points.length-1; iPt >= 0; --iPt ) 
                {
                    // check that the point isn't inside the other piece
                    // and that its edges don't intersect it
                    var pLeft = polygonOnTarget.points[ (iPt+polygonOnTarget.points.length-1)%polygonOnTarget.points.length ];
                    var pHere = polygonOnTarget.points[ iPt ];
                    var pRight = polygonOnTarget.points[ (iPt+1)%polygonOnTarget.points.length ];
                    if( otherPolygonOnTarget.contains( pHere ) ||
                        otherPolygonOnTarget.doesLineSegmentIntersect( pLeft, pHere ) || 
                        otherPolygonOnTarget.doesLineSegmentIntersect( pHere, pRight ) )
                    {
                        piece.removeVertex( iPt );
                        if( piece.atOrigin.points.length < 3 )
                        {
                            this.pieces.splice( iPiece, 1 );
                            pieceDeleted = true;
                            break;
                        }
                    }
                }
                if( pieceDeleted )
                    break;
            }
            if( pieceDeleted )
                break;
        }
    }
};
// --------------------------------------
World.prototype.adaptPieces = function( growStep ) {
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        this.pieces[ iPiece ].removeSelfIntersectingVertices();
    this.clipPiecesAgainstTargets();
    this.clipPiecesAgainstOthers();
    var somethingChanged = false;
    // move vertices outwards a little on their surface normal for as long as solution remains valid
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece ) 
    {
        var piece = this.pieces[ iPiece ];
        piece.subdivide( 20 );
        piece.removeVerticesCloserThan( 3 );
        for( var iPt = 0; iPt < piece.atOrigin.points.length; ++iPt ) 
        {
            var oldPos = new Point2D( piece.atOrigin.points[ iPt ].x, piece.atOrigin.points[ iPt ].y );
            var move = piece.atOrigin.getNormal( iPt ).mul( growStep );
            piece.atOrigin.points[ iPt ].add( move );
            var newPosIsOK = true;
            if( newPosIsOK )
            {
                for( var iTarget = 0; iTarget < piece.originToTarget.length; ++iTarget ) {
                    var pOnTarget = piece.originToTarget[ iTarget ].apply( piece.atOrigin.points[ iPt ] );
                    // check whether the point is still inside the target shape
                    if( !this.isPointInsideTarget( pOnTarget, iTarget ) ) {
                        newPosIsOK = false;
                        break;
                    }
                    // check whether the point doesn't intersect any other shape
                    for( var iOtherPiece = 0; iOtherPiece < this.pieces.length; ++iOtherPiece ) {
                        if( iOtherPiece == iPiece )
                            continue;
                        var otherPolygonOnTarget = this.pieces[ iOtherPiece ].getPolygonOnTarget( iTarget );
                        var left = piece.originToTarget[ iTarget ].apply( piece.atOrigin.points[ (iPt+piece.atOrigin.points.length-1)%piece.atOrigin.points.length ] );
                        var right = piece.originToTarget[ iTarget ].apply( piece.atOrigin.points[ (iPt+1)%piece.atOrigin.points.length ] );
                        if( otherPolygonOnTarget.doesLineSegmentIntersect( left, pOnTarget ) || otherPolygonOnTarget.doesLineSegmentIntersect( pOnTarget, right ) ) {
                            newPosIsOK = false;
                            break;
                        }
                    }
                    if( !newPosIsOK )
                        break;
                }            
            }
            if( !newPosIsOK )
                piece.atOrigin.points[ iPt ] = oldPos;
            else
                somethingChanged = true;
        }
        piece.recenter();
    }
    return somethingChanged;
};
// --------------------------------------
World.prototype.subdivideSelectedPiece = function() {
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        if( this.pieces[ iPiece ].isSelected() )
            this.pieces[ iPiece ].subdivide( 10 );
};
// --------------------------------------
World.prototype.simplifySelectedPiece = function() {
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        if( this.pieces[ iPiece ].isSelected() )
            this.pieces[ iPiece ].removeVerticesStraighterThan( 0.1 );
};
// --------------------------------------
World.prototype.isAnyPieceSelected = function() {
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        if( this.pieces[ iPiece ].isSelected() )
            return true;
    return false;
};
// --------------------------------------
World.prototype.onMouseMove = function( evt ) {
    // pass the message to the pieces
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        this.pieces[ iPiece ].onMouseMove( evt );
};
// --------------------------------------
World.prototype.onMouseLeftDown = function( evt ) {
    // was a button pressed?
    for( var iButton = 0; iButton < this.buttons.length; ++iButton ) {
        if( this.buttons[ iButton ].onMouseLeftDown( evt ) ) {
            this.doButtonAction( this.buttons[ iButton ].id, this.buttons[ iButton ].label );
            return;
        }
    }
    // send the message to the pieces
    var iPieceSelected = -1;
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece ) {
        if( this.pieces[ iPiece ].onMouseLeftDown( evt ) ) {
            iPieceSelected = iPiece;
            break; // we only allow one piece to accept the event
        }
    }
    // deselect everything other than the one that accepted the message
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece ) {
        if( iPiece != iPieceSelected )
            this.pieces[ iPiece ].state = PieceStateEnum.inactive;
    }
};
// --------------------------------------
World.prototype.onMouseLeftUp = function( evt ) {
    // tell the buttons
    for( var iButton = 0; iButton < this.buttons.length; ++iButton )
        this.buttons[ iButton ].onMouseLeftUp( evt );
};
// --------------------------------------
World.prototype.onMouseLeftDrag = function( evt ) {
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        this.pieces[ iPiece ].onMouseLeftDrag( evt );
};
// --------------------------------------
World.prototype.getSolutionData = function() {
    return {
                "N" : this.pieces.length,
                "percent" : this.getPercentCovered(),
                "circle" : { "center" : this.circleCenter, "radius" : this.circleRadius }, 
                "square" : { "center" : this.squareCenter, "radius" : this.squareRadius }, 
                "pieces" : this.pieces,
                "username" : this.username,
                "timestamp" : (new Date()).toJSON()
            };
};
// --------------------------------------
World.prototype.setSolutionData = function( solution ) {
    // adopt this solution for editing
    this.pieces = new Array();
    for( var iPiece = 0; iPiece < solution.pieces.length; ++iPiece ) {
        var piece = this.pieces[ iPiece ] = new Piece();
        for( var iPt = 0; iPt < solution.pieces[ iPiece].atOrigin.points.length; ++iPt )
            piece.atOrigin.points[ iPt ] = new Point2D( solution.pieces[ iPiece].atOrigin.points[ iPt ].x, solution.pieces[ iPiece].atOrigin.points[ iPt ].y );
        for( var iTarget = 0; iTarget < 2; ++iTarget )
            piece.originToTarget[ iTarget ] = new Transform( solution.pieces[ iPiece ].originToTarget[ iTarget ].rotate, solution.pieces[ iPiece ].originToTarget[ iTarget ].translate );
    }
    // (assuming for now that targets are the same)
};
// --------------------------------------
World.prototype.onRemoteSolutionAdded = function( solution ) {
    // reject entries we're not interested in
    if( !solution.N || solution.N < 1 || solution.N > 10 )
        return;
    // keep track of the winners on the leaderboard
    if( !this.leaderboard[ solution.N ] || solution.percent > this.leaderboard[ solution.N ].percent ) {
        this.leaderboard[ solution.N ] = solution;
        var iButton = this.iFirstLeaderboardButton + solution.N - 1;
        this.buttons[ iButton ].label = "N="+solution.N+" : "+this.leaderboard[ solution.N ].percent.toFixed(2)+"% ("+this.leaderboard[ solution.N ].username+")";
        this.buttons[ iButton ].isEnabled = true;
    }
    // add all the entries to the updates list
    this.updates.push( 
        { 
            time: new Date( solution.timestamp ), 
            text: "New record for N=" + solution.N + ": " + solution.percent.toFixed(2) + "% found by " + solution.username
        } );
    this.updates.sort( function( a, b ) { return b.time.getTime() - a.time.getTime(); } );
    // TODO: remove ones that weren't records (submitted before getting a server response about the leaderboard)
};
// --------------------------------------
World.prototype.onSubmitSolution = function() {
    this.username = prompt( "Enter a username:", this.username );
    if( this.username == null )
        return; // user cancelled when asked for username
    var dataRef = new Firebase("https://circle-squaring.firebaseio.com/solutions"); 
    dataRef.push( this.getSolutionData() ); 
};
// --------------------------------------
World.prototype.onSaveSolution = function() {
    prompt( "Copy JSON data from here:", JSON.stringify( this.getSolutionData() ) );
};
// --------------------------------------
World.prototype.onLoadSolution = function() {
    this.setSolutionData( JSON.parse( prompt( "Paste JSON data here:", "" ) ) );
};
// --------------------------------------
World.prototype.doButtonAction = function( id, label ) {
    switch( id ) {
        case "delete_piece":        this.deleteSelectedPiece(); break;
        case "clone_piece":         this.cloneSelectedPiece(); break;
        case "subdivide_piece":     this.subdivideSelectedPiece(); break;
        case "simplify_piece":      this.simplifySelectedPiece(); break;
        case "new_piece":           this.addNewPiece(); break;
        case "toggle_auto":         this.isAutoEnabled = !this.isAutoEnabled; 
                                    if( this.isAutoEnabled )
                                        this.automaticToggleButton.label = "Go manual"; 
                                    else
                                        this.automaticToggleButton.label = "Go auto"; 
                                    break;
        case "submit_solution":     this.onSubmitSolution(); break;
        case "save_solution":       this.onSaveSolution(); break;
        case "load_solution":       this.onLoadSolution(); break;
        case "leaderboard":         this.setSolutionData( this.leaderboard[ parseInt( label.substring(2) ) ] ); // leaderboard buttons are labelled e.g. "N=3 : ..."
                                    // TODO: should ask if OK to overwrite current work
                                    break;
        default: alert("Unknown button: "+label);
    }
};
// ======================================

(function() 
{
    var canvas  = document.getElementById( 'myCanvas' );
    var context = canvas.getContext( '2d' );
    var world   = new World( context );
    var mouseLeftDown = false;
    
    resizeCanvas();
    
    // events:

    var dataRef = new Firebase('https://circle-squaring.firebaseio.com/solutions');
    dataRef.on( 'child_added', function( data ) {
        world.onRemoteSolutionAdded( data.val() );
    });

    window.addEventListener( 'resize', resizeCanvas, false );
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        world.draw( canvas ); 
    };
    
    canvas.addEventListener( 'mousemove', function( evt ) {
        if( mouseLeftDown )
            world.onMouseLeftDrag( evt );
        else
            world.onMouseMove( evt );
        world.draw( canvas );
      }, false );

    canvas.addEventListener( 'mousedown', function( evt ) {
        if( evt.button == 0 ) {
            mouseLeftDown = true;
            world.onMouseLeftDown( evt );
            world.draw( canvas );
        }
      }, false );

    canvas.addEventListener( 'mouseup', function( evt ) {
        if( evt.button == 0 && mouseLeftDown ) {
            mouseLeftDown = false;
            world.onMouseLeftUp( evt );
            world.draw( canvas );
        }
      }, false );
      
    canvas.addEventListener( 'mouseout', function( evt ) {
        // if user drags the mouse out and then releases we won't receive the mouseUp event,
        // so instead we treat mouseOut as mouseUp (if button is pressed)
        if( mouseLeftDown ) {
            mouseLeftDown = false;
            world.onMouseLeftUp( evt );
            world.draw( canvas );
        }
      }, false );

    window.requestAnimFrame = (function(callback)
    {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
            function(callback) {
                window.setTimeout(callback, 1000 / 30);
            };
    })();

    function animate()
    {
        if( world.isAutoEnabled ) {
            var changed = world.adaptPieces( 3.0 );
            if( !changed )
                changed = world.adaptPieces( 1.0 );
            if( !changed )
                world.adaptPieces( 0.1 );
        }
        world.draw( canvas );

        // request new frame
        requestAnimFrame( animate );
    }
    animate();
    
})();
</script> 
</body>
</html>
