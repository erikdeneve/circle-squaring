<html>
<title>Circle-Squaring</title>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<meta content="utf-8" http-equiv="encoding">
<style>
* { margin:0; padding:0; } /* to remove the top and left whitespace */
html, body { width:100%; height:100%; } /* just to be sure these are full screen*/
canvas { display:block; } /* To remove the scrollbars */
</style>
</head>
<body>
<canvas id="myCanvas"></canvas> 
<script>
// ======================================
// utility functions
function crossProduct2D( v, w ) { return v.x*w.y - v.y*w.x; }
// --------------------------------------
function add( a, b ) { return new Point2D( a.x + b.x, a.y + b.y ); }
// --------------------------------------
function sub( a, b ) { return new Point2D( a.x - b.x, a.y - b.y ); }
// --------------------------------------
function sqr( x ) { return x * x }
// --------------------------------------
function dist2( v, w ) { return sqr(v.x - w.x) + sqr(v.y - w.y) }
// --------------------------------------
function distToSegmentSquared( p, v, w ) {
  var l2 = dist2(v, w);
  if (l2 == 0) return dist2(p, v);
  var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
  if (t < 0) return dist2(p, v);
  if (t > 1) return dist2(p, w);
  return dist2(p, { x: v.x + t * (w.x - v.x),
                    y: v.y + t * (w.y - v.y) });
}
// --------------------------------------
function distToSegment( p, v, w ) { return Math.sqrt(distToSegmentSquared(p, v, w)); }
// --------------------------------------
function lineSegmentsIntersect( p, p2, q, q2 ) {
    // two line segments: [p,p2] and [q,q2] - do they intersect?
    // http://stackoverflow.com/a/565282/126823
    var r = sub(p2, p);
    var s = sub(q2, q);

    var uNumerator = crossProduct2D(sub(q, p), r);
    var denominator = crossProduct2D(r, s);

    if( uNumerator == 0 && denominator == 0 ) {
        // colinear, so do they overlap?
        return ((q.x - p.x < 0) != (q.x - p2.x < 0) != (q2.x - p.x < 0) != (q2.x - p2.x < 0)) ||
                ((q.y - p.y < 0) != (q.y - p2.y < 0) != (q2.y - p.y < 0) != (q2.y - p2.y < 0));
    }

    if( denominator == 0 ) {
        // lines are parallel
        return false;
    }

    var u = uNumerator / denominator;
    var t = crossProduct2D(sub(q, p), s) / denominator;

    return (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);
};
// ======================================
// Point2D class
function Point2D( x, y ) {
    this.x = x;
    this.y = y;
};
// --------------------------------------
Point2D.prototype.add = function( p ) {
    this.x += p.x;
    this.y += p.y;
    return this;
};
// --------------------------------------
Point2D.prototype.sub = function( p ) {
    this.x -= p.x;
    this.y -= p.y;
    return this;
};
// --------------------------------------
Point2D.prototype.div = function( f ) {
    this.x /= f;
    this.y /= f;
    return this;
};
// --------------------------------------
Point2D.prototype.dist = function( p ) {
    return Math.sqrt( Math.pow( this.x - p.x, 2 ) + Math.pow( this.y - p.y, 2 ) );
};
// --------------------------------------
Point2D.prototype.getAsString = function() {
    return this.x + "," + this.y;
};
// ======================================
// Transform class
function Transform( r, p ) {
    this.rotate = r;           // radians
    this.translate = p;        // Point2D
};
// --------------------------------------
Transform.prototype.apply = function( p ) {
    return new Point2D( p.x * Math.cos( this.rotate ) - p.y * Math.sin( this.rotate ) + this.translate.x, 
                        p.x * Math.sin( this.rotate ) + p.y * Math.cos( this.rotate ) + this.translate.y );
};
// --------------------------------------
Transform.prototype.applyInverse = function( p ) {
    return new Point2D( ( p.x - this.translate.x ) * Math.cos( -this.rotate ) - ( p.y - this.translate.y ) * Math.sin( -this.rotate ), 
                        ( p.x - this.translate.x ) * Math.sin( -this.rotate ) + ( p.y - this.translate.y ) * Math.cos( -this.rotate ) );
};
// --------------------------------------
Transform.prototype.getAsString = function() {
    return this.rotate + "," + this.translate.getAsString();
};
// ======================================
// Polygon class
function Polygon() {
    this.points = new Array(); // a list of Point2D's
};
// --------------------------------------
Polygon.prototype.drawPath = function( ctx ) {
    if( this.points.length == 0 ) 
        return;
    ctx.beginPath();
    ctx.moveTo( this.points[0].x, this.points[0].y );
    for( var i = 1; i < this.points.length; ++i )
        ctx.lineTo( this.points[i].x, this.points[i].y );
    ctx.closePath();
};
// --------------------------------------
Polygon.prototype.getArea = function() {
    var area=0.0;
    var i, j = this.points.length-1;
    for( i = 0; i < this.points.length; ++i )
    {
        area += ( this.points[j].x + this.points[i].x ) * ( this.points[j].y - this.points[i].y ); 
        j = i;
    }
    return area * 0.5; 
};
// --------------------------------------
Polygon.prototype.getCentroid = function() {
    var centroid = new Point2D( 0, 0 );
    for( var i = 0; i < this.points.length; ++i )
        centroid.add( this.points[ i ] );
    return centroid.div( this.points.length ); 
};
// --------------------------------------
function getCircle( center, radius, n )
{
    var poly = new Polygon();
    for( var i = 0; i < n; ++i )
    {
        poly.points[i] = new Point2D( center.x + radius * Math.cos( i * 2.0 * Math.PI / n ), 
                                      center.y + radius * Math.sin( i * 2.0 * Math.PI / n ) );
    }
    return poly;
};
// --------------------------------------
Polygon.prototype.contains = function( p ) {
    var c = false;
    var i, j;
    var vertxi,vertyi,vertxj,vertyj;
    for( i = 0, j = this.points.length-1; i < this.points.length; j = i++ ) 
    {
        vertxi = this.points[i].x;
        vertyi = this.points[i].y;
        vertxj = this.points[j].x;
        vertyj = this.points[j].y;
        if ( ((vertyi>p.y) != (vertyj>p.y)) && (p.x < (vertxj-vertxi) * (p.y-vertyi) / (vertyj-vertyi) + vertxi) )
        {
            c = !c;
        }
    }
    return c;
};
// --------------------------------------
Polygon.prototype.getAsString = function() {
    var spec = this.points.length;
    for( var i = 0; i < this.points.length; ++i )
        spec += "," + this.points[i].getAsString();
    return spec;
};
// --------------------------------------
var PolygonRelationEnum = Object.freeze ({ disjoint: {}, contained: {}, containing: {}, intersecting: {} });
// --------------------------------------
Polygon.prototype.getPolygonRelationWith = function( poly ) {
    for( var i = 0; i < this.points.length; ++i )
    {
        var p = this.points[ i ];
        var p2 = this.points[ (i+1)%this.points.length ];
        for( var j = 0; j < poly.points.length; ++j )
        {
            var q = poly.points[ j ];
            var q2 = poly.points[ (j+1)%poly.points.length ];
            if( lineSegmentsIntersect( p, p2, q, q2 ) )
                return PolygonRelationEnum.intersecting;
        }
    }
    if( poly.contains( this.points[0] ) )
        return PolygonRelationEnum.contained;
    if( this.contains( poly.points[0] ) )
        return PolygonRelationEnum.containing;
    return PolygonRelationEnum.disjoint;
};
// --------------------------------------
Polygon.prototype.getTransformed = function( t ) {
    var poly = new Polygon();
    for( var iPt = 0; iPt < this.points.length; ++iPt )
        poly.points[ iPt ] = t.apply( this.points[ iPt ] );
    return poly;
};
// --------------------------------------
Polygon.prototype.isPointNearEdge = function( p, tol ) {
    for( var iPt = 0; iPt < this.points.length; ++iPt )
        if( distToSegment( p, this.points[iPt], this.points[ (iPt+1)%this.points.length ] ) < tol )
            return true;
    return false;
};
// ======================================
// Piece class
// --------------------------------------
var PieceStateEnum = Object.freeze ({ inactive: {}, highlighted: {}, selected: {}, translating: {}, vertexDragging: {}, rotating: {} });
// --------------------------------------
function Piece() {
    this.atOrigin = new Polygon();              // canonical polygon with centroid at the origin
    this.originToTarget = new Array();          // a Transform for each target
    this.state = PieceStateEnum.inactive;
    this.iActiveVertex = -1;
    this.whichTargetSelected = -1;
    this.draggingPoint = null;
    this.hue = Math.random() * 360.0;
    this.vertexRadius = 5;
};
// --------------------------------------
Piece.prototype.isSelected = function() {
    return this.state != PieceStateEnum.inactive && this.state != PieceStateEnum.highlighted;
}
// --------------------------------------
Piece.prototype.draw = function( ctx ) {
    // draw the pieces on each target
    for(var iTarget = 0; iTarget < this.originToTarget.length; ++iTarget ) 
    {
        ctx.strokeStyle = "rgb(0,0,0)";
        ctx.lineWidth = 1;
        if( this.state != PieceStateEnum.inactive )
            ctx.fillStyle = "hsla("+this.hue+",100%,50%,0.8)";
        else
            ctx.fillStyle = "hsla("+this.hue+",80%,50%,0.3)";
        ctx.save();
        ctx.translate( this.originToTarget[ iTarget ].translate.x, this.originToTarget[ iTarget ].translate.y );
        ctx.rotate( this.originToTarget[ iTarget ].rotate );
        this.atOrigin.drawPath( ctx );
        ctx.fill();
        if( this.isSelected() ) 
        {
            ctx.stroke();
            // draw vertex handles
            ctx.fillStyle = "rgba(0,0,0,0.4)";
            for( var iVert = 0; iVert < this.atOrigin.points.length; ++iVert ) {
                ctx.beginPath();
                ctx.arc( this.atOrigin.points[ iVert ].x, this.atOrigin.points[ iVert ].y, this.vertexRadius, 0, 2*Math.PI );
                ctx.fill();
                if( this.state == PieceStateEnum.vertexDragging && this.iActiveVertex == iVert )
                    ctx.stroke();
                ctx.closePath();
            }
        }
        ctx.restore();
    }
    // draw the cursor
    if( this.state == PieceStateEnum.rotating ) {
        // draw a broken circle to show that piece can be rotated like this
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = this.vertexRadius;
        var arcRadius = this.vertexRadius*2;
        ctx.beginPath();
        var pOnTarget = this.originToTarget[ this.whichTargetSelected ].apply( this.draggingPoint );
        ctx.arc( pOnTarget.x, pOnTarget.y, arcRadius, 0, 1.8 * Math.PI );
        ctx.stroke();
        ctx.closePath();
        // also draw the center of rotation
        var center = this.originToTarget[ this.whichTargetSelected ].apply( new Point2D( 0, 0 ) );
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.lineWidth = 1;
        var crossWidth = this.vertexRadius/2;
        ctx.beginPath();
        ctx.moveTo( center.x - crossWidth, center.y )
        ctx.lineTo( center.x + crossWidth, center.y )
        ctx.moveTo( center.x, center.y - crossWidth )
        ctx.lineTo( center.x, center.y + crossWidth )
        ctx.stroke();
        ctx.closePath();
    }
    else if( this.state == PieceStateEnum.translating ) {
        // draw a cross to show that piece can be moved like this
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = this.vertexRadius;
        var crossWidth = this.vertexRadius*2;
        ctx.beginPath();
        ctx.moveTo( this.draggingPoint.x - crossWidth, this.draggingPoint.y )
        ctx.lineTo( this.draggingPoint.x + crossWidth, this.draggingPoint.y )
        ctx.moveTo( this.draggingPoint.x, this.draggingPoint.y - crossWidth )
        ctx.lineTo( this.draggingPoint.x, this.draggingPoint.y + crossWidth )
        ctx.stroke();
        ctx.closePath();
    }
};
// --------------------------------------
Piece.prototype.getAsString = function() {
    var spec = this.atOrigin.getAsString() + "," + this.originToTarget.length + "," + this.hue;
    for( var i = 0; i < this.originToTarget.length; ++i )
        spec += "," + this.originToTarget[i].getAsString();
    return spec;
};
// --------------------------------------
Piece.prototype.getPolygonOnTarget = function( iTarget ) {
    return this.atOrigin.getTransformed( this.originToTarget[ iTarget ] ); // TODO: cache this, only update when needed
};
// --------------------------------------
Piece.prototype.recenter = function() {
    var center = this.atOrigin.getCentroid();
    for( var iPt = 0; iPt < this.atOrigin.points.length; ++iPt )
        this.atOrigin.points[ iPt ].sub( center );
    for( var iTarget = 0; iTarget < this.originToTarget.length; ++iTarget )
        this.originToTarget[ iTarget ].translate = this.originToTarget[ iTarget ].apply( center );
};
// --------------------------------------
Piece.prototype.onMouseMove = function( evt ) {
    var mousePos = new Point2D( evt.clientX, evt.clientY );
    // selected -> selected, translating, rotating or vertexDragging
    if( this.isSelected() )
    {
        for( var iTarget = 0; iTarget < this.originToTarget.length; ++iTarget ) 
        {
            var pAtOrigin = this.originToTarget[ iTarget ].applyInverse( mousePos );
        
            // in position for vertex dragging?
            for( var iVert = 0; iVert < this.atOrigin.points.length; ++iVert ) {
                if( pAtOrigin.dist( this.atOrigin.points[ iVert ] ) < this.vertexRadius ) {
                    this.state = PieceStateEnum.vertexDragging;
                    this.iActiveVertex = iVert;
                    this.draggingPoint = pAtOrigin;
                    this.whichTargetSelected = iTarget;
                    return;
                }
            }
            // in position for rotating the piece?
            if( this.atOrigin.isPointNearEdge( pAtOrigin, this.vertexRadius ) ) {
                this.state = PieceStateEnum.rotating;
                this.draggingPoint = pAtOrigin;
                this.whichTargetSelected = iTarget;
                return;
            }
            // in position for translating the piece?
            if( this.atOrigin.contains( pAtOrigin ) ) {
                this.state = PieceStateEnum.translating;
                this.draggingPoint = mousePos;
                this.whichTargetSelected = iTarget;
                return;
            }
        }
        this.state = PieceStateEnum.selected;
        this.whichTargetSelected = -1;
        return;
    }
    // inactive or highlighted
    for( var iTarget = 0; iTarget < this.originToTarget.length; ++iTarget )
    {
        var pAtOrigin = this.originToTarget[ iTarget ].applyInverse( mousePos );
        if( this.atOrigin.contains( pAtOrigin ) )
        {
            this.state = PieceStateEnum.highlighted;
            this.whichTargetSelected = iTarget;
            return;
        }
    }
    this.state = PieceStateEnum.inactive;
    this.whichTargetSelected = -1;
};
// --------------------------------------
Piece.prototype.onMouseLeftDown = function( evt ) {
    switch( this.state )
    {
        case PieceStateEnum.selected:
            this.state = PieceStateEnum.inactive;
            return false;
            
        case PieceStateEnum.highlighted:
            this.state = PieceStateEnum.selected;
            this.onMouseMove( evt ); // update the piece's state based on the mouse position
            return true; // no other piece should get this mouse click
            
        case PieceStateEnum.inactive:
            return false;
            
        default:
            return true; // translating/rotating/vertexDraggging is happening, no other piece should get this mouse click
    }
};
// --------------------------------------
Piece.prototype.onMouseLeftDrag = function( evt ) {
    var mousePos = new Point2D( evt.clientX, evt.clientY );
    switch( this.state ) 
    {
        case PieceStateEnum.vertexDragging:
            var pAtOrigin = this.originToTarget[ this.whichTargetSelected ].applyInverse( mousePos );
            this.atOrigin.points[ this.iActiveVertex ].add( sub( pAtOrigin, this.draggingPoint ) );
            this.recenter();
            this.draggingPoint = this.originToTarget[ this.whichTargetSelected ].applyInverse( mousePos ); // need to recompute because transform has changed
            break;
            
        case PieceStateEnum.translating:
            this.originToTarget[ this.whichTargetSelected ].translate.add( sub( mousePos, this.draggingPoint ) );
            this.draggingPoint = mousePos;
            break;
            
        case PieceStateEnum.rotating:
            var pAtOrigin = this.originToTarget[ this.whichTargetSelected].applyInverse( mousePos );
            this.originToTarget[ this.whichTargetSelected ].rotate += Math.atan2( pAtOrigin.y, pAtOrigin.x ) - Math.atan2( this.draggingPoint.y, this.draggingPoint.x );
            this.draggingPoint = this.originToTarget[ this.whichTargetSelected].applyInverse( mousePos ); // need to recompute because transform has changed
            break;
    }
};
// ======================================
// Button class
function Button( label, x, y, ctx ) {
    this.polygon = new Polygon();
    this.shadowPolygon = new Polygon();
    this.label = label;
    this.isEnabled = false;
    this.isPressed = false;
    // initialise a rectangle around the text
    this.fontHeight = 14;
    ctx.font = this.fontHeight + "px Arial";
    var textbox = ctx.measureText( label );
    var pad = 5;
    var shadowOffset = 4;
    this.polygon.points[0] = new Point2D( x - textbox.width/2 - pad, y - this.fontHeight/2 - pad );
    this.polygon.points[1] = new Point2D( x + textbox.width/2 + pad, y - this.fontHeight/2 - pad );
    this.polygon.points[2] = new Point2D( x + textbox.width/2 + pad, y + this.fontHeight/2 + pad*2 );
    this.polygon.points[3] = new Point2D( x - textbox.width/2 - pad, y + this.fontHeight/2 + pad*2 );
    this.textPos = new Point2D( this.polygon.points[3].x + pad, this.polygon.points[3].y - pad*2 )
    // make a shadow below and to the right
    for( var i = 0; i < this.polygon.points.length; ++i )
        this.shadowPolygon.points[ i ] = add( this.polygon.points[ i ], new Point2D( shadowOffset, shadowOffset ) );
};
// --------------------------------------
Button.prototype.draw = function( ctx ) {
    this.shadowPolygon.drawPath( ctx );
    ctx.fillStyle = "rgba(0,0,0,0.2)";
    ctx.fill();
    this.polygon.drawPath( ctx );
    if( !this.isEnabled )
        ctx.fillStyle = "rgb(230,230,230)";
    else if( this.isPressed )
        ctx.fillStyle = "rgb(255,255,255)";
    else
        ctx.fillStyle = "rgb(111,202,255)";
    ctx.fill();
    ctx.font = this.fontHeight + "px Arial";
    if( this.isEnabled )
        ctx.fillStyle = "rgb(0,0,0)";
    else
        ctx.fillStyle = "rgb(200,200,200)";
    ctx.fillText( this.label, this.textPos.x, this.textPos.y );
};
// --------------------------------------
Button.prototype.onMouseLeftDown = function( evt ) {
    if( !this.isEnabled )
        return false;
    var mousePos = new Point2D( evt.clientX, evt.clientY );
    if( this.polygon.contains( mousePos ) ) {
        this.isPressed = true;
        return true;
    }
    return false;
};
// --------------------------------------
Button.prototype.onMouseLeftUp = function( evt ) {
    this.isPressed = false;
};
// ======================================
// World class
function World( ctx ) {
    this.circleCenter = new Point2D( 250, 350 );
    this.circleRadius = 200.0;
    
    this.squareCenter = new Point2D( 650, 350 );
    this.squareRadius = this.circleRadius * Math.sqrt( Math.PI ) / 2.0;

    this.targets = new Array();
    
    this.targets[0] = getCircle( this.circleCenter, this.circleRadius, 100 );
    this.targets[1] = new Polygon();
    this.targets[1].points[0] = new Point2D( this.squareCenter.x - this.squareRadius, this.squareCenter.y - this.squareRadius );
    this.targets[1].points[1] = new Point2D( this.squareCenter.x - this.squareRadius, this.squareCenter.y + this.squareRadius );
    this.targets[1].points[2] = new Point2D( this.squareCenter.x + this.squareRadius, this.squareCenter.y + this.squareRadius );
    this.targets[1].points[3] = new Point2D( this.squareCenter.x + this.squareRadius, this.squareCenter.y - this.squareRadius );

    this.pieces = new Array();
    
    var test = this.pieces[0] = new Piece();
    test.atOrigin.points[0] = new Point2D( 34, 10 );
    test.atOrigin.points[1] = new Point2D( -10, -10 );
    test.atOrigin.points[2] = new Point2D( 7, 20 );
    test.originToTarget[0] = new Transform( 0.3, this.circleCenter );
    test.originToTarget[1] = new Transform( 0.6, this.squareCenter );
    test.recenter();
    
    var test2 = this.pieces[1] = new Piece();
    test2.atOrigin.points[0] = new Point2D( -17, 50 );
    test2.atOrigin.points[1] = new Point2D( 70, 20 );
    test2.atOrigin.points[2] = new Point2D( 34, 10 );
    test2.atOrigin.points[3] = new Point2D( -10, -10 );
    test2.originToTarget[0] = new Transform( 0.7, new Point2D( this.circleCenter.x - 50.0, this.circleCenter.y - 50.0 ) );
    test2.originToTarget[1] = new Transform( 2.8, new Point2D( this.squareCenter.x + 50.0, this.squareCenter.y - 50.0 ) );
    test2.recenter();
    
    this.buttons = new Array();
    
    this.deletePieceButton = this.buttons[0] = new Button( "Delete piece", 50, 20, ctx );
    this.buttons[1] = new Button( "New piece", 143, 20, ctx );
    this.buttons[1].isEnabled = true;
    this.buttons[2] = new Button( "Grow piece", 230, 20, ctx );
};
// --------------------------------------
World.prototype.draw = function( canvas ) {
    var context = canvas.getContext( "2d" );
    var isValidSolution = this.isValidSolution();
    
    // draw the background
    context.fillStyle = "rgb(200,200,200)";
    context.beginPath();
    context.fillRect( 0, 0, canvas.width, canvas.height );
    context.closePath();
    
    // update the buttons
    this.deletePieceButton.isEnabled = this.isAnyPieceSelected();
    
    // draw the buttons
    for( var iButton = 0; iButton < this.buttons.length; ++iButton )
        this.buttons[ iButton ].draw( context );
    
    // draw the targets
    context.fillStyle = "rgb(255,255,255)";
    for( var i = 0; i < this.targets.length; ++i ) {
        this.targets[i].drawPath( context );
        context.fill();
    }
        
    // draw the pieces (in reverse order so that the transparency appearance matches the selection behavior)
    for( var iPiece = this.pieces.length - 1; iPiece >= 0; --iPiece )
        this.pieces[ iPiece ].draw( context );
    
    // DEBUG: show some information
    context.fillStyle = "rgb(0,0,0)";
    context.font="12px Arial";
    context.fillText( this.getAsString(), 10, 70 );
    context.fillText( this.pieces.length + " : " + this.getAreaCovered()*100 + "%", 10, 100 );
    if( isValidSolution )
        context.fillText( "valid solution", 10, 130 );
    else
        context.fillText( "overlapping detected!", 10, 130 );
};
// --------------------------------------
World.prototype.isValidSolution = function() {
    var polysOnTarget = new Array();
    for( var iTarget = 0; iTarget < this.targets.length; ++iTarget ) {
        for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece ) {
            // transform each piece onto this target
            polysOnTarget[ iPiece ] = this.pieces[ iPiece ].getPolygonOnTarget( iTarget );
            // invalid if any piece not fully contained in each target
            if( polysOnTarget[ iPiece ].getPolygonRelationWith( this.targets[ iTarget ] ) != PolygonRelationEnum.contained ) 
                return false;
            // invalid if any piece not fully outside any other
            for( var iPiece2 = 0; iPiece2 < iPiece; ++iPiece2 ) 
                if( polysOnTarget[ iPiece ].getPolygonRelationWith( polysOnTarget[ iPiece2 ] ) != PolygonRelationEnum.disjoint ) 
                    return false;
        }
    }
    return true;
};
// --------------------------------------
World.prototype.getAreaCovered = function() {
    // assumes no overlapping
    var area = 0.0;
    for( var i = 0; i < this.pieces.length; ++i )
        area += this.pieces[i].atOrigin.getArea();
    return area / ( Math.PI * this.circleRadius * this.circleRadius );
};
// --------------------------------------
World.prototype.getAsString = function() {
    // targets:
    var spec = this.targets.length + "," + this.circleCenter.getAsString() + "," + this.circleRadius + ","
                + this.squareCenter.getAsString() + "," + this.squareRadius;
                
    // pieces:
    spec += "," + this.pieces.length;
    for( var i = 0; i < this.pieces.length; ++i )
        spec += "," + this.pieces[i].getAsString();
    return spec;
};
// --------------------------------------
World.prototype.addNewPiece = function() {
    var p = this.pieces[ this.pieces.length ] = new Piece();
    p.atOrigin.points[0] = new Point2D( -17, 50 );
    p.atOrigin.points[1] = new Point2D( 70, 20 );
    p.atOrigin.points[2] = new Point2D( 34, 10 );
    p.atOrigin.points[3] = new Point2D( -10, -10 );
    p.originToTarget[0] = new Transform( 0.7, new Point2D( this.circleCenter.x - 50.0, this.circleCenter.y - 50.0 ) );
    p.originToTarget[1] = new Transform( 2.8, new Point2D( this.squareCenter.x + 50.0, this.squareCenter.y - 50.0 ) );
    p.recenter();
};
// --------------------------------------
World.prototype.deleteSelectedPiece = function() {
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece ) {
        if( this.pieces[ iPiece ].isSelected() ) {
            this.pieces.splice( iPiece, 1 );
            return;
        }
    }
}
// --------------------------------------
World.prototype.isAnyPieceSelected = function() {
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        if( this.pieces[ iPiece ].isSelected() )
            return true;
    return false;
};
// --------------------------------------
World.prototype.onMouseMove = function( evt ) {
    // highlight whichever piece is underneath
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        this.pieces[ iPiece ].onMouseMove( evt );
};
// --------------------------------------
World.prototype.onMouseLeftDown = function( evt ) {
    // was a button pressed?
    for( var iButton = 0; iButton < this.buttons.length; ++iButton ) {
        if( this.buttons[ iButton ].onMouseLeftDown( evt ) ) {
            this.doButtonAction( this.buttons[ iButton ].label );
            return;
        }
    }
    // send the message to the pieces
    var iPieceSelected = -1;
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece ) {
        if( this.pieces[ iPiece ].onMouseLeftDown( evt ) ) {
            iPieceSelected = iPiece;
            break; // we only allow one piece to accept the event
        }
    }
    // deselect everything other than the one that accepted the message
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece ) {
        if( iPiece != iPieceSelected )
            this.pieces[ iPiece ].state = PieceStateEnum.inactive;
    }
};
// --------------------------------------
World.prototype.onMouseLeftUp = function( evt ) {
    // tell the buttons
    for( var iButton = 0; iButton < this.buttons.length; ++iButton )
        this.buttons[ iButton ].onMouseLeftUp( evt );
};
// --------------------------------------
World.prototype.onMouseLeftDrag = function( evt ) {
    for( var iPiece = 0; iPiece < this.pieces.length; ++iPiece )
        this.pieces[ iPiece ].onMouseLeftDrag( evt );
};
World.prototype.doButtonAction = function( label ) {
    switch( label ) {
        case "Delete piece": this.deleteSelectedPiece(); break;
        case "New piece":    this.addNewPiece(); break;
        case "Grow piece":   alert("Not yet implemented"); break;
    }
};
// ======================================

(function() 
{
    var canvas  = document.getElementById( 'myCanvas' );
    var context = canvas.getContext( '2d' );
    var world   = new World( context );
    var mouseLeftDown = false;
    
    resizeCanvas();
    
    // events:

    window.addEventListener( 'resize', resizeCanvas, false );
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        world.draw( canvas ); 
    };
    
    canvas.addEventListener( 'mousemove', function( evt ) {
        if( mouseLeftDown )
            world.onMouseLeftDrag( evt );
        else
            world.onMouseMove( evt );
        world.draw( canvas );
      }, false );

    canvas.addEventListener( 'mousedown', function( evt ) {
        if( evt.button == 0 ) {
            mouseLeftDown = true;
            world.onMouseLeftDown( evt );
            world.draw( canvas );
        }
      }, false );

    canvas.addEventListener( 'mouseup', function( evt ) {
        if( evt.button == 0 && mouseLeftDown ) {
            mouseLeftDown = false;
            world.onMouseLeftUp( evt );
            world.draw( canvas );
        }
      }, false );
      
    canvas.addEventListener( 'mouseout', function( evt ) {
        // if user drags the mouse out and then releases we won't receive the mouseUp event,
        // so instead we treat mouseOut as mouseUp (if button is pressed)
        if( mouseLeftDown ) {
            mouseLeftDown = false;
            world.onMouseLeftUp( evt );
            world.draw( canvas );
        }
      }, false );
      
})();
</script> 
</body>
</html>
